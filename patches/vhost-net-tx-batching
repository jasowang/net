Bottom: b18ab0ff75f424a9a7dc871a1c83ad017cfc434c
Top:    a656703b4706ac88abed75f8c091702a0d95336c
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-03-29 10:31:43 +0800

vhost-net: tx batching


---

diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index b5fb56b..8282150 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -110,6 +110,7 @@ struct vhost_net_virtqueue {
 	struct vhost_net_ubuf_ref *ubufs;
 	struct ptr_ring *rx_ring;
 	struct vhost_net_buf rxq;
+	struct tun_msg_ctl ctl;
 };
 
 struct vhost_net {
@@ -473,6 +474,7 @@ static void handle_tx(struct vhost_net *net)
 	struct socket *sock;
 	struct vhost_net_ubuf_ref *uninitialized_var(ubufs);
 	bool zcopy, zcopy_used;
+	int n = 0, off = 0;
 
 	mutex_lock(&vq->mutex);
 	sock = vq->private_data;
@@ -489,6 +491,8 @@ static void handle_tx(struct vhost_net *net)
 	zcopy = nvq->ubufs;
 
 	for (;;) {
+		struct tun_msg *m = &nvq->ctl.msgs[n];
+
 		/* Release DMAs done buffers first */
 		if (zcopy)
 			vhost_zerocopy_signal_used(net, vq);
@@ -515,16 +519,16 @@ static void handle_tx(struct vhost_net *net)
 		}
 		/* Skip header. TODO: support TSO. */
 		len = iov_length(vq->iov, out);
-		iov_iter_init(&msg.msg_iter, WRITE, vq->iov, out, len);
-		iov_iter_advance(&msg.msg_iter, hdr_size);
+		iov_iter_init(m->msg_iter, WRITE, vq->iov + off, out, len);
+		iov_iter_advance(m->msg_iter, hdr_size);
 		/* Sanity check */
-		if (!msg_data_left(&msg)) {
+		if (!msg_data_left(m)) {
 			vq_err(vq, "Unexpected header len for TX: "
 			       "%zd expected %zd\n",
 			       len, hdr_size);
 			break;
 		}
-		len = msg_data_left(&msg);
+		len = msg_data_left(m);
 
 		zcopy_used = zcopy && len >= VHOST_GOODCOPY_LEN
 				   && !vhost_exceeds_maxpend(net)
@@ -547,7 +551,8 @@ static void handle_tx(struct vhost_net *net)
 			atomic_inc(&ubufs->refcount);
 			nvq->upend_idx = (nvq->upend_idx + 1) % UIO_MAXIOV;
 		} else {
-			msg.msg_control = NULL;
+//			msg.msg_control = NULL;
+			msg->ubuf = NULL;
 			ubufs = NULL;
 		}
 
@@ -560,6 +565,10 @@ static void handle_tx(struct vhost_net *net)
 			msg.msg_flags &= ~MSG_MORE;
 		}
 
+		if (++n == VHOST_RX_BATCH) {
+			msg.msg_control = &nvq->ctl;
+		}
+
 		/* TODO: Check specific error and bomb out unless ENOBUFS? */
 		err = sock->ops->sendmsg(sock, &msg, len);
 		if (unlikely(err < 0)) {
diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index c5b0a75..da87d56 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -17,6 +17,18 @@
 
 #include <uapi/linux/if_tun.h>
 
+#define TUN_MAX_MSG 64
+
+struct tun_msg {
+	struct ubuf_info *ubuf;
+	struct iov_iter *iter;
+};
+
+struct tun_msg_ctl {
+	int n;
+	struct tun_msg msgs[TUN_MAX_MSG];
+};
+
 #define TUN_XDP_FLAG 0x1UL
 
 #if defined(CONFIG_TUN) || defined(CONFIG_TUN_MODULE)
