Bottom: be0726d5f340e2e9f21fbd6aebed075a935c2ebb
Top:    93dd1b2d8e46d67116eb2ef8aef279fb6a3053b9
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-08-06 17:03:09 +0800

virtio-net: zerocopy friendly driver

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 62311dd..0c5aa849 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -1078,6 +1078,9 @@ static int add_recvbuf_big(struct virtnet_info *vi, struct receive_queue *rq,
 	struct page *first, *list = NULL;
 	char *p;
 	int i, err, offset;
+	char *hdr = kmalloc(vi->hdr_len, GFP_ATOMIC);
+	if (!hdr)
+		return -ENOMEM;
 
 	sg_init_table(rq->sg, MAX_SKB_FRAGS + 2);
 
@@ -1087,6 +1090,7 @@ static int add_recvbuf_big(struct virtnet_info *vi, struct receive_queue *rq,
 		if (!first) {
 			if (list)
 				give_pages(rq, list);
+			kfree(hdr);
 			return -ENOMEM;
 		}
 		sg_set_buf(&rq->sg[i], page_address(first), PAGE_SIZE);
@@ -1099,24 +1103,27 @@ static int add_recvbuf_big(struct virtnet_info *vi, struct receive_queue *rq,
 	first = get_a_page(rq, gfp);
 	if (!first) {
 		give_pages(rq, list);
+		kfree(hdr);
 		return -ENOMEM;
 	}
 	p = page_address(first);
 
 	/* rq->sg[0], rq->sg[1] share the same page */
 	/* a separated rq->sg[0] for header - required in case !any_header_sg */
-	sg_set_buf(&rq->sg[0], p, vi->hdr_len);
+	sg_set_buf(&rq->sg[0], hdr, vi->hdr_len);
 
 	/* rq->sg[1] for data packet, from offset */
 	offset = sizeof(struct padded_vnet_hdr);
-	sg_set_buf(&rq->sg[1], p + offset, PAGE_SIZE - offset);
+	sg_set_buf(&rq->sg[1], p, PAGE_SIZE);
 
 	/* chain first in list head */
 	first->private = (unsigned long)list;
 	err = virtqueue_add_inbuf(rq->vq, rq->sg, MAX_SKB_FRAGS + 2,
 				  first, gfp);
-	if (err < 0)
+	if (err < 0) {
+		kfree(hdr);
 		give_pages(rq, first);
+	}
 
 	return err;
 }
