Bottom: ad01e2a21366fd53c049909d2943604bae7081b4
Top:    6ff871626e86e9928aa164e7a896e761dec3d45c
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-07-05 10:52:32 +0800

net: ipv4: fix use after free in ip_list_rcv()

When skb was freed by ip_rcv_core() its pointer was left in the list
which will lead use after free when trying to dispatching
sublist. Fixing by deleting skb before ip_rcv_core() and build sublist
one by one instead of list_cut_before().

Fixes:
Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 24b9b02..028fc19 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -577,24 +577,29 @@ void ip_list_rcv(struct list_head *head, struct packet_type *pt,
 	struct sk_buff *skb, *next;
 	struct list_head sublist;
 
+	INIT_LIST_HEAD(&sublist);
+
 	list_for_each_entry_safe(skb, next, head, list) {
 		struct net_device *dev = skb->dev;
 		struct net *net = dev_net(dev);
 
+		list_del(&skb->list);
 		skb = ip_rcv_core(skb, net);
 		if (skb == NULL)
 			continue;
 
 		if (curr_dev != dev || curr_net != net) {
 			/* dispatch old sublist */
-			list_cut_before(&sublist, head, &skb->list);
-			if (!list_empty(&sublist))
+			if (!list_empty(&sublist)) {
 				ip_sublist_rcv(&sublist, dev, net);
+				INIT_LIST_HEAD(&sublist);
+			}
 			/* start new sublist */
 			curr_dev = dev;
 			curr_net = net;
 		}
+		list_add_tail(&skb->list, &sublist);
 	}
 	/* dispatch final sublist */
-	ip_sublist_rcv(head, curr_dev, curr_net);
+	ip_sublist_rcv(&sublist, curr_dev, curr_net);
 }
