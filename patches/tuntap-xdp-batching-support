Bottom: 9c90c117b90afcfb6366389c47f10cee69985cad
Top:    5e3b03ddc15d5daf825fc06a07e054b64855d215
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-04-17 07:40:09 +0800

tuntap: XDP batching support


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 40d2c05..80f5317 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -182,6 +182,9 @@ struct tun_file {
 	struct tun_struct *detached;
 	struct ptr_ring tx_ring;
 	struct xdp_rxq_info xdp_rxq;
+	struct xdp_buff xdp[NAPI_POLL_WEIGHT];
+	u16 xdp_head;
+	u16 xdp_tail;
 };
 
 struct tun_flow_entry {
@@ -1664,12 +1667,14 @@ static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 				     int len, int *skb_xdp)
 {
 	struct page_frag *alloc_frag = &current->task_frag;
+	struct xdp_buff *xdp = &tfile->xdp[tfile->xdp_tail];
 	struct sk_buff *skb = NULL;
 	struct bpf_prog *xdp_prog;
 	int buflen = SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 	char *buf;
 	size_t copied;
 	int pad = TUN_RX_PAD;
+	int *lenp;
 
 	rcu_read_lock();
 	xdp_prog = rcu_dereference(tun->xdp_prog);
@@ -1689,17 +1694,27 @@ static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 	if (copied != len)
 		return ERR_PTR(-EFAULT);
 
+	get_page(alloc_frag->page);
+	alloc_frag->offset += buflen;
+
 	/* There's a small window that XDP may be set after the check
 	 * of xdp_prog above, this should be rare and for simplicity
 	 * we do XDP on skb in case the headroom is not enough.
 	 */
-	if (hdr->gso_type || !xdp_prog)
+	if (hdr->gso_type || !xdp_prog) {
 		*skb_xdp = 1;
-	else
-		*skb_xdp = 0;
+		goto build:
+	}
 
-	get_page(alloc_frag->page);
-	alloc_frag->offset += buflen;
+	*skb_xdp = 0;
+
+	xdp->data_hard_start = buf;
+	xdp->data = buf + pad;
+	xdp_set_data_meta_invalid(&dp);
+	xdp->data_end = xdp->data + len;
+	xdp->rxq = &tfile->xdp_rxq;
+	lenp = (int *)xdp->data_hard_start;
+	*lenp = buflen;
 
 	preempt_disable();
 	rcu_read_lock();
@@ -1719,6 +1734,7 @@ static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 		goto out;
 	}
 
+build:
 	skb = build_skb(buf, buflen);
 	if (!skb) {
 		put_page(alloc_frag->page);
@@ -3246,6 +3262,8 @@ static int tun_chr_open(struct inode *inode, struct file * file)
 
 	memset(&tfile->tx_ring, 0, sizeof(tfile->tx_ring));
 
+	tfile->xdp_head = tfile->xdp_tail = 0;
+
 	return 0;
 }
