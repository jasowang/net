Bottom: 3e625c4b139a35af10aacb2348744e13d0ab090c
Top:    248a9dbbbc57e0d70dc859d10d64e8015551058d
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-04-17 07:40:09 +0800

tuntap: XDP batching support

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 554cd57..e533168 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -182,6 +182,10 @@ struct tun_file {
 	struct tun_struct *detached;
 	struct ptr_ring tx_ring;
 	struct xdp_rxq_info xdp_rxq;
+	struct xdp_buff xdp[NAPI_POLL_WEIGHT];
+	u16 xdp_head;
+	u16 xdp_tail;
+	bool xdp_xmit;
 };
 
 struct tun_flow_entry {
@@ -1604,8 +1608,7 @@ static bool tun_can_build_skb(struct tun_struct *tun, struct tun_file *tfile,
 static struct sk_buff *tun_do_xdp(struct tun_struct *tun,
 				  struct tun_file *tfile,
 				  struct bpf_prog *xdp_prog,
-				  struct xdp_buff *xdp,
-				  int buflen)
+				  struct xdp_buff *xdp)
 {
 	u32 act = bpf_prog_run_xdp(xdp_prog, xdp);
 	struct sk_buff *skb = NULL;
@@ -1613,20 +1616,24 @@ static struct sk_buff *tun_do_xdp(struct tun_struct *tun,
 	unsigned int delta = 0;
 	int pad = xdp->data - xdp->data_hard_start;
 	int len = xdp->data_end - xdp->data;
+	int buflen = *(int *)xdp->data_hard_start;
 	int err;
 
+	if (!xdp_prog)
+		goto build;
+
 	switch (act) {
 	case XDP_REDIRECT:
 		err = xdp_do_redirect(tun->dev, xdp, xdp_prog);
-		xdp_do_flush_map();
 		if (err)
 			goto err_xdp;
+		tfile->xdp_xmit = true;
 		goto out;
 	case XDP_TX:
 		err = tun_xdp_xmit(tun->dev, xdp);
 		if (err)
 			goto err_xdp;
-		tun_xdp_flush(tun->dev);
+		tfile->xdp_xmit = true;
 		goto out;
 	case XDP_PASS:
 		delta = orig_data - xdp->data;
@@ -1642,6 +1649,7 @@ static struct sk_buff *tun_do_xdp(struct tun_struct *tun,
 		goto err_xdp;
 	}
 
+build:
 	skb = build_skb(xdp->data_hard_start, buflen);
 	if (!skb) {
 		err = -ENOMEM;
@@ -1658,6 +1666,40 @@ static struct sk_buff *tun_do_xdp(struct tun_struct *tun,
 	return ERR_PTR(err);
 }
 
+static void tun_flush_xdp(struct tun_struct *tun,
+			  struct tun_file *tfile)
+{
+	struct bpf_prog *xdp_prog;
+	struct sk_buff *skb;
+
+	if (tfile->xdp_head == tfile->xdp_tail)
+		return;
+
+	preempt_disable();
+	rcu_read_lock();
+	xdp_prog = rcu_dereference(tun->xdp_prog);
+
+	while (tfile->xdp_head != tfile->xdp_tail) {
+		struct xdp_buff *xdp = &tfile->xdp[tfile->xdp_head++];
+		skb = tun_do_xdp(tun, tfile, xdp_prog, xdp);
+		/* FIXME, receive */
+		if (skb)
+			kfree_skb(skb);
+	}
+
+	if (tfile->xdp_xmit) {
+		xdp_do_flush_map();
+		tun_xdp_flush(tun->dev);
+		tfile->xdp_xmit = false;
+	}
+
+	tfile->xdp_head = tfile->xdp_tail = 0;
+	rcu_read_unlock();
+	preempt_enable();
+
+	return;
+}
+
 static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 				     struct tun_file *tfile,
 				     struct iov_iter *from,
@@ -1665,12 +1707,17 @@ static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 				     int len, int *skb_xdp)
 {
 	struct page_frag *alloc_frag = &current->task_frag;
+	struct xdp_buff *xdp = &tfile->xdp[tfile->xdp_tail];
 	struct sk_buff *skb = NULL;
 	struct bpf_prog *xdp_prog;
 	int buflen = SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 	char *buf;
 	size_t copied;
 	int pad = TUN_RX_PAD;
+	int *lenp;
+
+	if (tfile->xdp_tail == NAPI_POLL_WEIGHT)
+		tun_flush_xdp(tun, tfile);
 
 	rcu_read_lock();
 	xdp_prog = rcu_dereference(tun->xdp_prog);
@@ -1698,31 +1745,24 @@ static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 	 * we do XDP on skb in case the headroom is not enough.
 	 */
 	if (hdr->gso_type || !xdp_prog) {
+		/* Flush pending XDP to avoid OOO */
+		tun_flush_xdp(tun, tfile);
 		*skb_xdp = 1;
 		goto build;
 	}
 
 	*skb_xdp = 0;
 
-	preempt_disable();
-	rcu_read_lock();
-	xdp_prog = rcu_dereference(tun->xdp_prog);
-	if (xdp_prog && !*skb_xdp) {
-		struct xdp_buff xdp;
+	xdp->data_hard_start = buf;
+	xdp->data = buf + pad;
+	xdp_set_data_meta_invalid(xdp);
+	xdp->data_end = xdp->data + len;
+	xdp->rxq = &tfile->xdp_rxq;
+	lenp = (int *)xdp->data_hard_start;
+	*lenp = buflen;
 
-		xdp.data_hard_start = buf;
-		xdp.data = buf + pad;
-		xdp_set_data_meta_invalid(&xdp);
-		xdp.data_end = xdp.data + len;
-		xdp.rxq = &tfile->xdp_rxq;
-
-		skb = tun_do_xdp(tun, tfile, xdp_prog, &xdp, buflen);
-		if (PTR_ERR(skb))
-			goto err_xdp;
-		goto out;
-	}
-	rcu_read_unlock();
-	preempt_enable();
+	++tfile->xdp_tail;
+	goto out;
 
 build:
 	skb = build_skb(buf, buflen);
@@ -1734,14 +1774,7 @@ static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 
 	skb_reserve(skb, pad);
 	skb_put(skb, len);
-
-	return skb;
-
-err_xdp:
-	this_cpu_inc(tun->pcpu_stats->rx_dropped);
 out:
-	rcu_read_unlock();
-	preempt_enable();
 	return skb;
 }
 
@@ -3249,6 +3282,9 @@ static int tun_chr_open(struct inode *inode, struct file * file)
 
 	memset(&tfile->tx_ring, 0, sizeof(tfile->tx_ring));
 
+	tfile->xdp_head = tfile->xdp_tail = 0;
+	tfile->xdp_xmit = false;
+
 	return 0;
 }
