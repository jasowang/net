Bottom: 07105105380ea9c2c7dc9ab8e6d8e7d9cd225142
Top:    3c1a35083774cdf79110b6cc0f17ab73c29f3243
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-09-26 11:16:36 +0800

Refresh of dynamic

---

diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 550f414..380edbb 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -31,6 +31,7 @@
 #include <linux/if_vlan.h>
 #include <linux/skb_array.h>
 #include <linux/skbuff.h>
+#include <linux/average.h>
 
 #include <net/sock.h>
 
@@ -102,6 +103,8 @@ struct vhost_net_buf {
 	int head;
 };
 
+DECLARE_EWMA(gap_ns, 0, 64);
+
 struct vhost_net_virtqueue {
 	struct vhost_virtqueue vq;
 	size_t vhost_hlen;
@@ -119,7 +122,7 @@ struct vhost_net_virtqueue {
 	struct skb_array *rx_array;
 	struct vhost_net_buf rxq;
 	struct hrtimer early_timer;
-	u64 poll_ns;
+	struct ewma_gap_ns avg_gap_ns;
 	u64 last_start;
 	int busy_state;
 };
@@ -429,23 +432,24 @@ static int vhost_net_tx_get_vq_desc(struct vhost_net *net,
 	unsigned long uninitialized_var(endtime);
 	int r = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov),
 				  out_num, in_num, NULL, NULL);
-	u64 end;
+	u64 end, poll_ns;
 
 	if (r == vq->num && vq->busyloop_timeout) {
 		tvq->last_start = ktime_get_ns();
-		if (tvq->busy_state == VHOST_NET_BUSY_POLL &&
-		    tvq->poll_ns < vq->busyloop_timeout << 10 &&
-		    tvq->poll_ns >> 10) {
-			tvq->busy_state = VHOST_NET_BUSY_SLEEP;
-			hrtimer_start(&tvq->early_timer,
-				      tvq->poll_ns / 4,
-				      HRTIMER_MODE_REL);
-			return vq->num;
+		poll_ns = ewma_gap_ns_read(&tvq->avg_gap_ns);
+		if (tvq->busy_state == VHOST_NET_BUSY_POLL) {
+			if (poll_ns < vq->busyloop_timeout << 10 &&
+			    poll_ns >> 10) {
+				tvq->busy_state = VHOST_NET_BUSY_SLEEP;
+				hrtimer_start(&tvq->early_timer, poll_ns / 2,
+					      HRTIMER_MODE_REL);
+				return vq->num;
+			}
 		}
 		preempt_disable();
 		endtime = busy_clock() + vq->busyloop_timeout;
-		if (hrtimer_active(&tvq->early_timer))
-			endtime -= tvq->poll_ns >> 10;
+		if (tvq->busy_state == VHOST_NET_BUSY_SLEEP)
+			endtime -= poll_ns >> 11;
 		while (vhost_can_busy_poll(vq->dev, endtime) &&
 		       vhost_vq_avail_empty(vq->dev, vq))
 			cpu_relax();
@@ -456,8 +460,11 @@ static int vhost_net_tx_get_vq_desc(struct vhost_net *net,
 
 	if (vq->busyloop_timeout) {
 		tvq->busy_state = VHOST_NET_BUSY_POLL;
-		end = ktime_get_ns();
-		tvq->poll_ns = ktime_to_ns(ktime_sub(end, tvq->last_start));
+		if (r != vq->num) {
+			end = ktime_get_ns();
+			poll_ns = ktime_to_ns(ktime_sub(end, tvq->last_start));
+			ewma_gap_ns_add(&tvq->avg_gap_ns, poll_ns);
+		}
 	}
 
 	return r;
@@ -655,18 +662,20 @@ static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk)
 	struct vhost_virtqueue *vq = &nvq->vq;
 	unsigned long uninitialized_var(endtime);
 	int len = peek_head_len(rvq, sk);
-	u64 end;
+	u64 end, poll_ns;
 
 	if (!len && vq->busyloop_timeout) {
 		rvq->last_start = ktime_get_ns();
-		if (rvq->busy_state == VHOST_NET_BUSY_POLL &&
-		    rvq->poll_ns < vq->busyloop_timeout << 10 &&
-		    rvq->poll_ns >> 10) {
-			rvq->busy_state = VHOST_NET_BUSY_SLEEP;
-			hrtimer_start(&rvq->early_timer,
-				      rvq->poll_ns / 4,
-				      HRTIMER_MODE_REL);
-			return 0;
+		poll_ns = ewma_gap_ns_read(&rvq->avg_gap_ns);
+		if (rvq->busy_state == VHOST_NET_BUSY_POLL) {
+			if (poll_ns < vq->busyloop_timeout << 10 &&
+			    poll_ns >> 10) {
+				rvq->busy_state = VHOST_NET_BUSY_SLEEP;
+				hrtimer_start(&rvq->early_timer,
+					      poll_ns / 2,
+					      HRTIMER_MODE_REL);
+				return 0;
+			}
 		}
 
 		/* Both tx vq and rx socket were polled here */
@@ -675,8 +684,8 @@ static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk)
 
 		preempt_disable();
 		endtime = busy_clock() + vq->busyloop_timeout;
-		if (!hrtimer_active(&rvq->early_timer))
-			endtime -= rvq->poll_ns >> 10;
+		if (rvq->busy_state == VHOST_NET_BUSY_SLEEP)
+			endtime -= poll_ns >> 11;
 
 		while (vhost_can_busy_poll(&net->dev, endtime) &&
 		       !sk_has_rx_data(sk) &&
@@ -699,8 +708,11 @@ static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk)
 
 	if (vq->busyloop_timeout) {
 		rvq->busy_state = VHOST_NET_BUSY_POLL;
-		end = ktime_get_ns();
-		rvq->poll_ns = ktime_to_ns(ktime_sub(end, rvq->last_start));
+		if (len) {
+			end = ktime_get_ns();
+			poll_ns = ktime_to_ns(ktime_sub(end, rvq->last_start));
+			ewma_gap_ns_add(&rvq->avg_gap_ns, poll_ns);
+		}
 	}
 
 	return len;
@@ -1017,7 +1029,7 @@ static int vhost_net_open(struct inode *inode, struct file *f)
 			     HRTIMER_MODE_REL);
 		n->vqs[i].early_timer.function = vhost_net_early_wakeup;
 		n->vqs[i].busy_state = VHOST_NET_BUSY_SLEEP;
-		n->vqs[i].poll_ns = 0;
+		ewma_gap_ns_init(&n->vqs[i].avg_gap_ns);
 	}
 	vhost_dev_init(dev, vqs, VHOST_NET_VQ_MAX);
