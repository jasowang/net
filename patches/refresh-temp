Bottom: 20bb643d3772961e3baded397146b545c09c3535
Top:    a51fc86c8b3ed1bce6877badf02b729eee8de9a6
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-07-03 13:09:50 +0800

Refresh of style-fix

---

diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 477494f..215d72b 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -1407,7 +1407,7 @@ long vhost_vring_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *arg
 		s.num = vq->last_avail_idx;
 		if (vhost_has_feature(vq, VIRTIO_F_RING_PACKED))
 			s.num |= vq->last_avail_wrap_counter << 31;
-		if (copy_to_user(argp, &s, sizeof s))
+		if (copy_to_user(argp, &s, sizeof(s)))
 			r = -EFAULT;
 		break;
 	case VHOST_SET_VRING_USED_BASE:
@@ -1418,7 +1418,7 @@ long vhost_vring_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *arg
 			r = -EBUSY;
 			break;
 		}
-		if (copy_from_user(&s, argp, sizeof s)) {
+		if (copy_from_user(&s, argp, sizeof(s))) {
 			r = -EFAULT;
 			break;
 		}
@@ -2012,7 +2012,7 @@ static int get_indirect_packed(struct vhost_virtqueue *vq,
 	if (unlikely(len % sizeof(desc))) {
 		vq_err(vq, "Invalid length in indirect descriptor: len 0x%llx not multiple of 0x%zx\n",
 		       (unsigned long long)len,
-		       sizeof desc);
+		       sizeof(desc));
 		return -EINVAL;
 	}
 
@@ -2028,12 +2028,14 @@ static int get_indirect_packed(struct vhost_virtqueue *vq,
 	iov_iter_init(&from, READ, vq->indirect, ret, len);
 
 	/* We will use the result as an address to read from, so most
-	 * architectures only need a compiler barrier here. */
+	 * architectures only need a compiler barrier here.
+	 */
 	read_barrier_depends();
 
-	count = len / sizeof desc;
+	count = len / sizeof(desc);
 	/* Buffers are chained via a 16 bit next field, so
-	 * we can have at most 2^16 of these. */
+	 * we can have at most 2^16 of these.
+	 */
 	if (unlikely(count > USHRT_MAX + 1)) {
 		vq_err(vq, "Indirect buffer length too big: %d\n",
 		       indirect->len);
@@ -2041,10 +2043,10 @@ static int get_indirect_packed(struct vhost_virtqueue *vq,
 	}
 
 	do {
-		unsigned iov_count = *in_num + *out_num;
+		unsigned int iov_count = *in_num + *out_num;
+
 		if (unlikely(++found > count)) {
-			vq_err(vq, "Loop detected: last one at %u "
-			       "indirect size %u\n",
+			vq_err(vq, "Loop detected: last one at %u indirect size %u\n",
 			       i, count);
 			return -EINVAL;
 		}
@@ -2052,14 +2054,14 @@ static int get_indirect_packed(struct vhost_virtqueue *vq,
 						  &from))) {
 			vq_err(vq, "Failed indirect descriptor: idx %d, %zx\n",
 			       i, (size_t)vhost64_to_cpu(vq, indirect->addr)
-				  + i * sizeof desc);
+				  + i * sizeof(desc));
 			return -EINVAL;
 		}
 		if (unlikely(desc.flags &
 			     cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT))) {
 			vq_err(vq, "Nested indirect descriptor: idx %d, %zx\n",
 			       i, (size_t)vhost64_to_cpu(vq, indirect->addr)
-				  + i * sizeof desc);
+				  + i * sizeof(desc));
 			return -EINVAL;
 		}
 
@@ -2074,8 +2076,7 @@ static int get_indirect_packed(struct vhost_virtqueue *vq,
 				     iov_size - iov_count, access);
 		if (unlikely(ret < 0)) {
 			if (ret != -EAGAIN)
-				vq_err(vq, "Translation failure %d "
-					   "indirect idx %d\n",
+				vq_err(vq, "Translation failure %d indirect idx %d\n",
 				       ret, i);
 			return ret;
 		}
@@ -2091,10 +2092,10 @@ static int get_indirect_packed(struct vhost_virtqueue *vq,
 			}
 		} else {
 			/* If it's an output descriptor, they're all supposed
-			 * to come before any input descriptors. */
+			 * to come before any input descriptors.
+			 */
 			if (unlikely(*in_num)) {
-				vq_err(vq, "Indirect descriptor "
-				       "has out after in: idx %d\n", i);
+				vq_err(vq, "Indirect descriptor has out after in: idx %d\n", i);
 				return -EINVAL;
 			}
 			*out_num += ret;
@@ -2137,12 +2138,12 @@ static bool vhost_vring_packed_need_event(struct vhost_virtqueue *vq,
 					  bool wrap, __u16 off_wrap, __u16 new,
 					  __u16 old)
 {
-    int off = off_wrap & ~(1 << 15);
+	int off = off_wrap & ~(1 << 15);
 
-    if (wrap != off_wrap >> 15)
-	    off -= vq->num;
+	if (wrap != off_wrap >> 15)
+		off -= vq->num;
 
-    return vring_need_event(off, new, old);
+	return vring_need_event(off, new, old);
 }
 
 static int vhost_get_vq_desc_packed(struct vhost_virtqueue *vq,
@@ -2177,7 +2178,8 @@ static int vhost_get_vq_desc_packed(struct vhost_virtqueue *vq,
 			return -EFAULT;
 		}
 
-		if (!desc_is_avail(vq, vq->last_avail_wrap_counter, desc.flags)) {
+		if (!desc_is_avail(vq, vq->last_avail_wrap_counter,
+				   desc.flags)) {
 			/* If there's nothing new since last we looked, return
 			 * invalid.
 			 */
@@ -2206,9 +2208,7 @@ static int vhost_get_vq_desc_packed(struct vhost_virtqueue *vq,
 						  log_num, &desc);
 			if (unlikely(ret < 0)) {
 				if (ret != -EAGAIN)
-					vq_err(vq, "Failure detected "
-						   "in indirect descriptor "
-						   "at idx %d\n", i);
+					vq_err(vq, "Failure detected in indirect descriptor at idx %d\n", i);
 				return ret;
 			}
 			goto next;
@@ -2254,8 +2254,7 @@ static int vhost_get_vq_desc_packed(struct vhost_virtqueue *vq,
 
 next:
 		if (unlikely(++used->count > vq->num)) {
-			vq_err(vq, "Loop detected: last one at %u "
-			       "vq size %u head %u\n",
+			vq_err(vq, "Loop detected: last one at %u vq size %u head %u\n",
 			       i, vq->num, used->elem.id);
 			return -EINVAL;
 		}
@@ -2640,9 +2639,9 @@ static int vhost_add_used_packed(struct vhost_virtqueue *vq,
 		smp_wmb();
 	}
 
-	ret = vhost_put_user(vq, get_desc_flags(vq, wrap_counter,
-						used->elem.len),
-		             &desc->flags, VHOST_ADDR_DESC);
+	ret = vhost_put_user(vq,
+			     get_desc_flags(vq, wrap_counter, used->elem.len),
+			     &desc->flags, VHOST_ADDR_DESC);
 	if (unlikely(ret)) {
 		vq_err(vq, "Failed to update flags: idx %d addr %p\n",
 		       vq->last_used_idx, desc);
@@ -2880,7 +2879,8 @@ static bool vhost_enable_notify_packed(struct vhost_dev *dev,
 	/* TODO: enable notification through device area */
 
 	/* They could have slipped one in as we were doing that: make
-	 * sure it's written, then check again. */
+	 * sure it's written, then check again.
+	 */
 	smp_mb();
 
 	ret = vhost_get_user(vq, flags, &d->flags, VHOST_ADDR_DESC);
diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h
index 5b7786f..db09958 100644
--- a/drivers/vhost/vhost.h
+++ b/drivers/vhost/vhost.h
@@ -210,8 +210,8 @@ void vhost_set_used_len(struct vhost_virtqueue *vq,
 			int len);
 int vhost_get_used_len(struct vhost_virtqueue *vq,
 		       struct vhost_used_elem *used);
-void vhost_discard_vq_desc(struct vhost_virtqueue *,
-			   struct vhost_used_elem *,
+void vhost_discard_vq_desc(struct vhost_virtqueue *vq,
+			   struct vhost_used_elem *elem,
 			   int n);
 
 int vhost_vq_init_access(struct vhost_virtqueue *);
diff --git a/include/uapi/linux/vhost.h b/include/uapi/linux/vhost.h
index 7c21da9..4c7c32d 100644
--- a/include/uapi/linux/vhost.h
+++ b/include/uapi/linux/vhost.h
@@ -161,9 +161,11 @@ struct vhost_memory {
 					 struct vhost_vring_state)
 
 /* Base value where queue looks for used descriptors */
-#define VHOST_SET_VRING_USED_BASE _IOW(VHOST_VIRTIO, 0x25, struct vhost_vring_state)
+#define VHOST_SET_VRING_USED_BASE _IOW(VHOST_VIRTIO, 0x25,	\
+                                  struct vhost_vring_state)
 /* Get accessor: reads index, writes value in num */
-#define VHOST_GET_VRING_USED_BASE _IOWR(VHOST_VIRTIO, 0x26, struct vhost_vring_state)
+#define VHOST_GET_VRING_USED_BASE _IOWR(VHOST_VIRTIO, 0x26,	\
+                                  struct vhost_vring_state)
 
 /* VHOST_NET specific defines */
