Bottom: d2c7c3e29e917f41219663b5304073f6583b5764
Top:    7bc4eb68ac99c70ab41f7187563c4c8dbb752631
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-07-05 17:05:42 +0800

Refresh of virtio-net-basic-ebpf-offload

---

diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 695f038..f603d20 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -228,6 +228,8 @@ struct virtnet_info {
 	struct bpf_prog *bpf_offloaded;
 	u32 bpf_offloaded_id;
 
+	u32 prog_id_gen;
+
 	bool bpf_bind_accept;
 	u32 bpf_bind_verifier_delay;
 	struct dentry *ddir_bpf_bound_progs;
@@ -259,6 +261,9 @@ struct virtnet_bpf_bound_prog {
 	struct list_head l;
 };
 
+#define pr_vlog(env, fmt, ...)	\
+	bpf_verifier_log_write(env, "[netdevsim] " fmt, ##__VA_ARGS__)
+
 /* Converting between virtqueue no. and kernel tx/rx queue no.
  * 0:rx0 1:tx0 2:rx1 3:tx1 ... 2N:rxN 2N+1:txN 2N+2:cvq
  */
@@ -2363,6 +2368,64 @@ static u32 virtnet_xdp_query(struct net_device *dev)
 	return 0;
 }
 
+static int virtnet_debugfs_bpf_string_read(struct seq_file *file, void *data)
+{
+	const char **str = file->private;
+
+	if (*str)
+		seq_printf(file, "%s\n", *str);
+
+	return 0;
+}
+
+static int virtnet_debugfs_bpf_string_open(struct inode *inode, struct file *f)
+{
+	return single_open(f, virtnet_debugfs_bpf_string_read,
+			   inode->i_private);
+}
+
+static const struct file_operations virtnet_bpf_string_fops = {
+	.owner = THIS_MODULE,
+	.open = virtnet_debugfs_bpf_string_open,
+	.release = single_release,
+	.read = seq_read,
+	.llseek = seq_lseek
+};
+
+static int virtnet_bpf_create_prog(struct virtnet_info *vi,
+				   struct bpf_prog *prog)
+{
+	struct virtnet_bpf_bound_prog *state;
+	char name[16];
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	state->vi = vi;
+	state->prog = prog;
+	state->state = "verify";
+
+	/* Program id is not populated yet when we create the state. */
+	sprintf(name, "%u", vi->prog_id_gen++);
+	state->ddir = debugfs_create_dir(name, vi->ddir_bpf_bound_progs);
+	if (IS_ERR_OR_NULL(state->ddir)) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	debugfs_create_u32("id", 0400, state->ddir, &prog->aux->id);
+	debugfs_create_file("state", 0400, state->ddir,
+			    &state->state, &virtnet_bpf_string_fops);
+	debugfs_create_bool("loaded", 0400, state->ddir, &state->is_loaded);
+
+	list_add_tail(&state->l, &vi->bpf_bound_progs);
+
+	prog->aux->offload->dev_priv = state;
+
+	return 0;
+}
+
 static int
 virtnet_bpf_verify_insn(struct bpf_verifier_env *env, int insn_idx,
 			int prev_insn)
@@ -2385,7 +2448,7 @@ static const struct bpf_prog_offload_ops virtnet_bpf_analyzer_ops = {
 
 static int virtnet_bpf(struct net_device *dev, struct netdev_bpf *bpf)
 {
-	struct virtnet_info *vi;
+	struct virtnet_info *vi = netdev_priv(dev);
 	int err;
 
 	switch (bpf->command) {
