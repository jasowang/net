Bottom: 850e2a96d4e7041c6a150a09fd07ddbee58bcca4
Top:    ea08cadd38863bfbe486de904f6e7a107dc7f747
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-07-20 11:32:16 +0800

Refresh of net-sock-introduce-sock_xdp

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 6691b9d..bc7cebf 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -868,6 +868,9 @@ static int tun_attach(struct tun_struct *tun, struct file *file,
 		tun_napi_init(tun, tfile, napi);
 	}
 
+	if (rtnl_dereference(tun->xdp_prog))
+		sock_set_flag(&tfile->sk, SOCK_XDP);
+
 	tun_set_real_num_queues(tun);
 
 	/* device is allowed to go away first, so no need to hold extra
@@ -1240,13 +1243,29 @@ static int tun_xdp_set(struct net_device *dev, struct bpf_prog *prog,
 		       struct netlink_ext_ack *extack)
 {
 	struct tun_struct *tun = netdev_priv(dev);
+	struct tun_file *tfile;
 	struct bpf_prog *old_prog;
+	int i;
 
 	old_prog = rtnl_dereference(tun->xdp_prog);
 	rcu_assign_pointer(tun->xdp_prog, prog);
 	if (old_prog)
 		bpf_prog_put(old_prog);
 
+	for (i = 0; i < tun->numqueues; i++) {
+		tfile = rtnl_dereference(tun->tfiles[i]);
+		if (prog)
+			sock_set_flag(&tfile->sk, SOCK_XDP);
+		else
+			sock_reset_flag(&tfile->sk, SOCK_XDP);
+	}
+	list_for_each_entry(tfile, &tun->disabled, next) {
+		if (prog)
+			sock_set_flag(&tfile->sk, SOCK_XDP);
+		else
+			sock_reset_flag(&tfile->sk, SOCK_XDP);
+	}
+
 	return 0;
 }
 
@@ -2493,7 +2512,7 @@ static int tun_sendmsg(struct socket *sock, struct msghdr *m, size_t total_len)
 		rcu_read_lock();
 
 		for (i = 0; i < n; i++) {
-			xdp = &((struct xdp_buff *)ctl->ptr)[i]);
+			xdp = &((struct xdp_buff *)ctl->ptr)[i];
 			tun_xdp_one(tun, tfile, xdp);
 		}
