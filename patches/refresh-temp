Bottom: b1de394448ccd8c4851be4183f9d7f92aa319e35
Top:    e1226f466d05c668e8c318d30dd4c18327e29a30
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-11-16 19:49:08 +0800

Refresh of had

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 1588469..f45f2e2 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1157,6 +1157,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	size_t total_len = iov_iter_count(from);
 	size_t len = total_len, align = tun->align, linear;
 	struct virtio_net_hdr gso = { 0 };
+	__virtio16 num_buffers;
 	struct tun_pcpu_stats *stats;
 	int good_linear;
 	int copylen;
@@ -1179,28 +1180,55 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	}
 
 	if (tun->flags & IFF_VNET_HDR) {
-		if (len < tun->vnet_hdr_sz)
+		if (len < tun->vnet_hdr_sz) {
+			printk("len is too small!\n");
 			return -EINVAL;
+		}
 		len -= tun->vnet_hdr_sz;
 
 		n = copy_from_iter(&gso, sizeof(gso), from);
-		if (n != sizeof(gso))
+		if (n != sizeof(gso)) {
+			printk("gso copy failed!\n");
 			return -EFAULT;
+		}
+
+		if (unlikely(len < ETH_HLEN ||
+			     (gso.hdr_len && tun16_to_cpu(tun, gso.hdr_len) < ETH_HLEN)))
+		{
+			printk("early!\n");
+		}
 
 		if ((gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&
 		    tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2 > tun16_to_cpu(tun, gso.hdr_len))
 			gso.hdr_len = cpu_to_tun16(tun, tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2);
 
-		if (tun16_to_cpu(tun, gso.hdr_len) > len)
+		if (tun16_to_cpu(tun, gso.hdr_len) > len) {
+			printk("hdr_len error!\n");
 			return -EINVAL;
-		iov_iter_advance(from, tun->vnet_hdr_sz - sizeof(gso));
+		}
+		copy_from_iter(&num_buffers, sizeof(num_buffers), from);
+		iov_iter_advance(from, tun->vnet_hdr_sz - sizeof(gso)
+				- sizeof(num_buffers));
 	}
 
 	if ((tun->flags & TUN_TYPE_MASK) == IFF_TAP) {
 		align += NET_IP_ALIGN;
 		if (unlikely(len < ETH_HLEN ||
 			     (gso.hdr_len && tun16_to_cpu(tun, gso.hdr_len) < ETH_HLEN)))
+		{
+
+			int i;
+			printk("hdr check error!, gso.hdr_len is %x gso_type %x\n",
+				tun16_to_cpu(tun, gso.hdr_len), gso.gso_type);
+			printk("nbuffers %d\n", num_buffers);
+
+			for (i = 0; i < sizeof(struct virtio_net_hdr);
+			     i ++) {
+				printk("gso[%d] %x\n", i, ((char *)&gso)[i]);
+			}
+
 			return -EINVAL;
+		}
 	}
 
 	good_linear = SKB_MAX_HEAD(align);
@@ -1254,6 +1282,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 
 	err = virtio_net_hdr_to_skb(skb, &gso, tun_is_little_endian(tun));
 	if (err) {
+		printk("header conversion error!\n");
 		this_cpu_inc(tun->pcpu_stats->rx_frame_errors);
 		kfree_skb(skb);
 		return -EINVAL;
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 2cafd12..b2a9a78 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -821,11 +821,13 @@ static void free_old_xmit_skbs(struct send_queue *sq)
 static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 {
 	struct virtio_net_hdr_mrg_rxbuf *hdr;
+	struct virtio_net_hdr hdr2;
 	const unsigned char *dest = ((struct ethhdr *)skb->data)->h_dest;
 	struct virtnet_info *vi = sq->vq->vdev->priv;
 	unsigned num_sg;
 	unsigned hdr_len = vi->hdr_len;
 	bool can_push;
+	int ret;
 
 	pr_debug("%s: xmit %p %pM\n", vi->dev->name, skb, dest);
 
@@ -843,12 +845,18 @@ static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 				    virtio_is_little_endian(vi->vdev)))
 		BUG();
 
+	hdr->num_buffers = 0xFF;
+	hdr->hdr.hdr_len = 0;
+
 	if (vi->mergeable_rx_bufs)
 		hdr->num_buffers = 0;
 
 	sg_init_table(sq->sg, skb_shinfo(skb)->nr_frags + (can_push ? 1 : 2));
 	if (can_push) {
 		__skb_push(skb, hdr_len);
+		skb_copy_bits(skb, 0, &hdr2, sizeof(hdr2));
+		if (hdr2.hdr_len && hdr2.hdr_len < ETH_HLEN)
+			BUG();
 		num_sg = skb_to_sgvec(skb, sq->sg, 0, skb->len);
 		/* Pull header back to avoid skew in tx bytes calculations. */
 		__skb_pull(skb, hdr_len);
@@ -856,7 +864,16 @@ static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 		sg_set_buf(sq->sg, hdr, hdr_len);
 		num_sg = skb_to_sgvec(skb, sq->sg + 1, 0, skb->len) + 1;
 	}
-	return virtqueue_add_outbuf(sq->vq, sq->sg, num_sg, skb, GFP_ATOMIC);
+	if (hdr->hdr.hdr_len && hdr->hdr.hdr_len < ETH_HLEN)
+		BUG();
+
+	BUG_ON(hdr->hdr.gso_size != 0xFF);
+
+	ret = virtqueue_add_outbuf(sq->vq, sq->sg, num_sg, skb, GFP_ATOMIC);
+	if (hdr->hdr.hdr_len && hdr->hdr.hdr_len < ETH_HLEN)
+		BUG();
+
+	return ret;
 }
 
 static netdev_tx_t start_xmit(struct sk_buff *skb, struct net_device *dev)
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 5dc128a..62dbad9 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -372,6 +372,8 @@ static void handle_tx(struct vhost_net *net)
 	struct socket *sock;
 	struct vhost_net_ubuf_ref *uninitialized_var(ubufs);
 	bool zcopy, zcopy_used;
+	struct iov_iter header;
+	struct virtio_net_hdr hdr;
 
 	mutex_lock(&vq->mutex);
 	sock = vq->private_data;
@@ -420,6 +422,12 @@ static void handle_tx(struct vhost_net *net)
 		/* Skip header. TODO: support TSO. */
 		len = iov_length(vq->iov, out);
 		iov_iter_init(&msg.msg_iter, WRITE, vq->iov, out, len);
+		iov_iter_init(&header, WRITE, vq->iov, out, len);
+		copy_from_iter(&hdr, sizeof(hdr), &header);
+		if (hdr.hdr_len && hdr.hdr_len <= ETH_HLEN) {
+			printk("error len %d\n", hdr.hdr_len);
+		}
+		printk("vhost hdr size %d\n", hdr_size);
 		iov_iter_advance(&msg.msg_iter, hdr_size);
 		/* Sanity check */
 		if (!msg_data_left(&msg)) {
diff --git a/include/linux/virtio_net.h b/include/linux/virtio_net.h
index 1c912f8..2c0f30a 100644
--- a/include/linux/virtio_net.h
+++ b/include/linux/virtio_net.h
@@ -68,6 +68,7 @@ static inline int virtio_net_hdr_from_skb(const struct sk_buff *skb,
 						 skb_headlen(skb));
 		hdr->gso_size = __cpu_to_virtio16(little_endian,
 						  sinfo->gso_size);
+                printk("hdr_len is %d\n", hdr->hdr_len);
 		if (sinfo->gso_type & SKB_GSO_TCPV4)
 			hdr->gso_type = VIRTIO_NET_HDR_GSO_TCPV4;
 		else if (sinfo->gso_type & SKB_GSO_TCPV6)
@@ -95,6 +96,8 @@ static inline int virtio_net_hdr_from_skb(const struct sk_buff *skb,
 		hdr->flags = VIRTIO_NET_HDR_F_DATA_VALID;
 	} /* else everything is zero */
 
+        hdr->gso_size = 0xFF;
+
 	return 0;
 }
