Bottom: 27b0315ec3770841902a29a954627da1fa0862af
Top:    9b62601f95b19758395150e7b59c5e74ba074ef3
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-05-09 17:10:28 +0800

Refresh of formal-patch

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 5b6a546..41c09d0 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1536,25 +1536,61 @@ done:
 	return total;
 }
 
-static struct sk_buff *tun_recv_datagram(struct tun_struct *tun,
-					 struct tun_file *tfile,
-					 int noblock,
-					 int *err)
+static struct sk_buff *tun_ring_recv(struct tun_struct *tun,
+				     struct tun_file *tfile,
+				     int noblock,
+				     int *err)
 {
-	int peeked, off = 0;
-	if (tun->flags & IFF_TX_RING) {
-		struct sk_buff *skb;
+	DECLARE_WAITQUEUE(wait, current);
+	struct sk_buff *skb = NULL;
+
+	if (unlikely(!noblock)) {
+		add_wait_queue(&tfile->wq.wait, &wait);
+		current->state = TASK_INTERRUPTIBLE;
+	}
+
+	while(1) {
 		spin_lock(&tfile->rlock);
 		if (tfile->head == tfile->tail) {
 			spin_unlock(&tfile->rlock);
-			*err = -EAGAIN;
-			return NULL;
+			if (noblock) {
+				*err = -EAGAIN;
+				break;
+			}
+			if (signal_pending(current)) {
+				*err = -ERESTARTSYS;
+				break;
+			}
+			if (tun->dev->reg_state != NETREG_REGISTERED) {
+				*err = -EIO;
+				break;
+			}
+			/* Nothing to read, let's sleep */
+			schedule();
+			continue;
 		}
 		skb = tfile->tx_descs[tfile->head].skb;
 		smp_wmb();
 		tfile->head = (tfile->head + 1) & TUN_RING_MASK;
 		spin_unlock(&tfile->rlock);
-		return skb;
+	}
+
+	if (unlikely(!noblock)) {
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&tfile->wq.wait, &wait);
+	}
+
+	return skb;
+}
+
+static struct sk_buff *tun_recv_datagram(struct tun_struct *tun,
+					 struct tun_file *tfile,
+					 int noblock,
+					 int *err)
+{
+	int peeked, off = 0;
+	if (tun->flags & IFF_TX_RING) {
+		return tun_ring_recv(tun, tfile, noblock, err);
 	} else {
 		/* Read frames from queue */
 		return __skb_recv_datagram(tfile->socket.sk,
