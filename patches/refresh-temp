Bottom: 6e3064ca3e35603d1c5a1a4165d4c6623b032a23
Top:    2d54396df390d54ac78fea02e3e36e47c758ce03
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-12-19 20:56:47 +0800

Refresh of macvtap-xdp-fast-rx-support

---

diff --git a/drivers/net/macvlan.c b/drivers/net/macvlan.c
index 20b3fdf2..f34c99f 100644
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@ -90,6 +90,19 @@ static struct macvlan_port *macvlan_port_get_rtnl(const struct net_device *dev)
 	return rtnl_dereference(dev->rx_handler_data);
 }
 
+struct macvlan_dev *macvlan_get_dev(const struct net_device *lowerdev)
+{
+	struct macvlan_port *port = macvlan_port_get_rcu(lowerdev);
+	struct macvlan_dev *dev;
+
+	dev =  list_first_or_null_rcu(&port->vlans,
+				struct macvlan_dev, list);
+	printk("get port %p lowerdev %p macvlan_dev %p\n", port,
+	       lowerdev, dev);
+	return dev;
+}
+EXPORT_SYMBOL_GPL(macvlan_get_dev);
+
 #define macvlan_port_exists(dev) (dev->priv_flags & IFF_MACVLAN_PORT)
 
 static struct macvlan_dev *macvlan_hash_lookup(const struct macvlan_port *port,
@@ -1134,6 +1147,8 @@ static int macvlan_port_create(struct net_device *dev)
 		kfree(port);
 	else
 		dev->priv_flags |= IFF_MACVLAN_PORT;
+
+	printk("port %p lowerdev %p\n", port, dev);
 	return err;
 }
 
@@ -1365,6 +1380,7 @@ int macvlan_common_newlink(struct net *src_net, struct net_device *dev,
 	if (err)
 		goto unregister_netdev;
 
+	printk("vlan %p add to port %p\n", vlan, port);
 	list_add_tail_rcu(&vlan->list, &port->vlans);
 	netif_stacked_transfer_operstate(lowerdev, dev);
 	linkwatch_fire_event(dev);
diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c
index 9277d7c..fd46005 100644
--- a/drivers/net/macvtap.c
+++ b/drivers/net/macvtap.c
@@ -212,6 +212,8 @@ static int macvtap_set_queue(struct net_device *dev, struct file *file,
 	rcu_assign_pointer(vlan->taps[vlan->numvtaps], q);
 	sock_hold(&q->sk);
 
+	printk("vlan %p queue %d p %p\n", vlan, vlan->numvtaps, q);
+
 	q->file = file;
 	q->queue_index = vlan->numvtaps;
 	q->enabled = true;
@@ -359,22 +361,32 @@ static void macvtap_del_queues(struct net_device *dev)
 static unsigned int macvtap_xdp_rx(const void *ctx,
 				   const struct bpf_insn *filter)
 {
-	struct xdp_buff *buff;
-	struct net_device *dev = ((struct xdp_buff *)ctx)->dev;
+	struct xdp_buff *buff = ctx;
+	struct net_device *dev = buff->dev;
 	struct macvlan_dev *vlan;
 	struct macvtap_queue *q;
 
-	vlan = macvtap_get_vlan_rcu(dev);
+	printk("ctx %p dev %p\n", ctx, dev);
+	vlan = macvlan_get_dev(dev);
 	if (!vlan)
 		return XDP_PASS;
 
+	printk("vlan %p\n", vlan);
 	buff = kmemdup(ctx, sizeof(*buff), GFP_ATOMIC);
 	if (!buff)
 		return XDP_DROP;
 
 	q = rcu_dereference(vlan->taps[0]);
-	if (!ptr_ring_produce(&q->xdp_array, buff))
+	if (!q) {
+		printk("noqueue! vlan %p\n", vlan);
+		return XDP_DROP;
+	}
+	printk("q %p XDP array %p\n", q, &q->xdp_array);
+	if (ptr_ring_produce(&q->xdp_array, buff)) {
+		kfree(buff);
+		printk("full!\n");
 		goto drop;
+	}
 
 	wake_up_interruptible_poll(sk_sleep(&q->sk), POLLIN |
 				   POLLRDNORM | POLLRDBAND);
@@ -1067,7 +1079,7 @@ static ssize_t macvtap_read_iter(struct kiocb *iocb, struct iov_iter *to)
 	struct macvtap_queue *q = file->private_data;
 	ssize_t len = iov_iter_count(to), ret;
 
-	ret = macvtap_do_read(q, to, file->f_flags & O_NONBLOCK);
+	ret = macvtap_do_read_xdp(q, to, file->f_flags & O_NONBLOCK);
 	ret = min_t(ssize_t, ret, len);
 	if (ret > 0)
 		iocb->ki_pos = ret;
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 5142e9c..d03b9e8 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -379,6 +379,7 @@ static virtnet_xdp_buff_free(const void *r, const void *data)
 	struct receive_queue *rq = r;
 	struct page *page = data;
 
+	printk("free!\n");
 	give_pages(rq, page);
 }
 
diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index a4ccc31..7ad884f 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -87,6 +87,9 @@ extern void macvlan_common_setup(struct net_device *dev);
 extern int macvlan_common_newlink(struct net *src_net, struct net_device *dev,
 				  struct nlattr *tb[], struct nlattr *data[]);
 
+extern struct macvlan_dev *macvlan_get_dev(const struct net_device *lowerdev);
+
+
 extern void macvlan_count_rx(const struct macvlan_dev *vlan,
 			     unsigned int len, bool success,
 			     bool multicast);
