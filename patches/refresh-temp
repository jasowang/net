Bottom: 3d40ea727c14552c309467ff195d63263bc6ec94
Top:    c5c269fa930d6b370358741973d3285f8eea309a
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-03-02 14:15:58 +0800

Refresh of vhost-prefetch-desc-indices

---

diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index b8260e2..28f50ec 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -724,6 +724,7 @@ static void handle_rx(struct vhost_net *net)
 						&in, vq_log, &log, UIO_MAXIOV);
 		} else {
 			unsigned int out;
+			printk("cur %d ndescs %d\n", cur, ndescs);
 			if (cur == ndescs) {
 				npkts = sk_rx_array_length(sock->sk);
 				printk("npkts %d\n", npkts);
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 38a9801..33003c7 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -1922,17 +1922,20 @@ int vhost_prefetch_desc_indices(struct vhost_virtqueue *vq,
 		return -EFAULT;
 	}
 	vq->avail_idx = vhost16_to_cpu(vq, avail_idx);
+	printk("num %d avail %d\n", num, vq->avail_idx - vq->last_avail_idx);
 	ret = total = min(num, vq->avail_idx - vq->last_avail_idx);
 
 	last_avail_idx = vq->last_avail_idx & (vq->num - 1);
 	while (total) {
+		int ret2;
+
 		left = vq->num - last_avail_idx;
 		left = min(total, left);
 
-		ret = vhost_copy_from_user(vq, indices,
-					   &vq->avail->ring[last_avail_idx],
-					   sizeof(avail_idx) * left);
-		if (unlikely(ret)) {
+		ret2 = vhost_copy_from_user(vq, indices,
+					    &vq->avail->ring[last_avail_idx],
+					    sizeof(avail_idx) * left);
+		if (unlikely(ret2)) {
 			vq_err(vq, "Failed to get descriptors\n");
 			return -EFAULT;
 		}
@@ -1944,6 +1947,7 @@ int vhost_prefetch_desc_indices(struct vhost_virtqueue *vq,
 	/* Only get avail ring entries after they have been exposed by guest. */
 	smp_rmb();
 
+	printk("ret is %d\n", ret);
 	return ret;
 }
 EXPORT_SYMBOL(vhost_prefetch_desc_indices);
diff --git a/include/linux/ptr_ring.h b/include/linux/ptr_ring.h
index 73cbe89..a9e28a6 100644
--- a/include/linux/ptr_ring.h
+++ b/include/linux/ptr_ring.h
@@ -174,14 +174,6 @@ static inline void *__ptr_ring_peek(struct ptr_ring *r)
 	return NULL;
 }
 
-static inline int __ptr_ring_peek_queue_len(struct ptr_ring *r)
-{
-	if (r->producer >= r->consumer)
-		return r->producer - r->consumer;
-	else
-		return r->producer + r->size - r->consumer;
-}
-
 /* Note: callers invoking this in a loop must use a compiler barrier,
  * for example cpu_relax(). Callers must take consumer_lock
  * if the ring is ever resized - see e.g. ptr_ring_empty.
@@ -191,6 +183,16 @@ static inline bool __ptr_ring_empty(struct ptr_ring *r)
 	return !__ptr_ring_peek(r);
 }
 
+static inline int __ptr_ring_peek_queue_len(struct ptr_ring *r)
+{
+	if (__ptr_ring_empty(r))
+		return 0;
+	else if (r->producer > r->consumer)
+		return r->producer - r->consumer;
+	else
+		return r->producer + r->size - r->consumer;
+}
+
 static inline bool ptr_ring_empty(struct ptr_ring *r)
 {
 	bool ret;
