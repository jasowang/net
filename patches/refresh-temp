Bottom: e6c3414b507a56c0c338d78a5d3778ca60c149e9
Top:    309ef252e1f9667bf8c9a77d5f617ad5da03bc46
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-01-26 16:31:33 +0800

Refresh of debug

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 6988746..ec03caf 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1753,27 +1753,36 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	if (tun->flags & IFF_VNET_HDR) {
 		int vnet_hdr_sz = READ_ONCE(tun->vnet_hdr_sz);
 
-		if (len < vnet_hdr_sz)
+		if (len < vnet_hdr_sz) {
+			printk("tun vnet hdr sz!\n");
 			return -EINVAL;
+		}
 		len -= vnet_hdr_sz;
 
-		if (!copy_from_iter_full(&gso, sizeof(gso), from))
+		if (!copy_from_iter_full(&gso, sizeof(gso), from)) {
+			printk("tun gso !\n");
 			return -EFAULT;
+		}
 
 		if ((gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&
 		    tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2 > tun16_to_cpu(tun, gso.hdr_len))
 			gso.hdr_len = cpu_to_tun16(tun, tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2);
 
-		if (tun16_to_cpu(tun, gso.hdr_len) > len)
+		if (tun16_to_cpu(tun, gso.hdr_len) > len) {
+			printk("tun hdr len\n");
 			return -EINVAL;
+		}
 		iov_iter_advance(from, vnet_hdr_sz - sizeof(gso));
 	}
 
 	if ((tun->flags & TUN_TYPE_MASK) == IFF_TAP) {
 		align += NET_IP_ALIGN;
 		if (unlikely(len < ETH_HLEN ||
-			     (gso.hdr_len && tun16_to_cpu(tun, gso.hdr_len) < ETH_HLEN)))
+				(gso.hdr_len && tun16_to_cpu(tun,
+		gso.hdr_len) < ETH_HLEN))){
+			printk("tun hdr check!\n");
 			return -EINVAL;
+		}
 	}
 
 	good_linear = SKB_MAX_HEAD(align);
@@ -1802,10 +1811,13 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 		skb = tun_build_skb(tun, tfile, from, &gso, len, &skb_xdp);
 		if (IS_ERR(skb)) {
 			this_cpu_inc(tun->pcpu_stats->rx_dropped);
+			printk("tun can't build!\n");
 			return PTR_ERR(skb);
 		}
-		if (!skb)
+		if (!skb) {
+			printk("tun sbk NULL!\n");
 			return total_len;
+		}
 	} else {
 		if (!zerocopy) {
 			copylen = len;
@@ -1833,6 +1845,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 				this_cpu_inc(tun->pcpu_stats->rx_dropped);
 			if (frags)
 				mutex_unlock(&tfile->napi_mutex);
+			printk("tun skb err!\n");
 			return PTR_ERR(skb);
 		}
 
@@ -1849,6 +1862,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 				mutex_unlock(&tfile->napi_mutex);
 			}
 
+			printk("tun copy err!\n");
 			return -EFAULT;
 		}
 	}
@@ -1861,6 +1875,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 			mutex_unlock(&tfile->napi_mutex);
 		}
 
+		printk("tun vnet hdr conversion!\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index e1e91d3..c49cedc 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -2003,6 +2003,7 @@ static int vhost_read_indices(struct vhost_virtqueue *vq, u16 num)
 	if (indices->read_tail != indices->tail)
 		printk("vq %p read_tail is not equal to tail\n", vq);
 
+	printk("vq %p last_avail is %d\n", vq, vq->last_avail_idx);
 	if (unlikely(vhost_get_avail(vq, avail_idx, &vq->avail->idx))) {
 		vq_err(vq, "Failed to access avail idx at %p\n",
 		       &vq->avail->idx);
@@ -2036,6 +2037,8 @@ static int vhost_read_indices(struct vhost_virtqueue *vq, u16 num)
 	}
 
 	vq->last_avail_idx += ret;
+	printk("vq %p total %d last_avail_idx %d\n", vq, ret,
+		vq->last_avail_idx);
 
 	/* Only get avail ring entries after they have been exposed by guest. */
 	smp_rmb();
@@ -2167,8 +2170,20 @@ static struct vring_desc *vhost_next_desc(struct vhost_virtqueue *vq,
 	}
 
 	if (advance) {
-		printk("adv read tail is %d head %d\n",
-			indices->read_tail, indices->head);
+		/* This happens when we read descs more than indices */
+		if (indices->read_tail == indices->head) {
+			int ret = vhost_read_indices(vq, 64);
+			if (ret < 0) {
+				printk("vq %p fail to read indices\n", vq);
+				return ERR_PTR(-EFAULT);
+			}
+			if (ret == 0) {
+				/* BUG() */
+				return NULL;
+			}
+		}
+		printk("vq %p adv read tail is %d head %d\n",
+			vq, indices->read_tail, indices->head);
 		*head = indices->indices[indices->read_tail++];
 	}
 	desc = &descs->descs[descs->tail++];
@@ -2286,9 +2301,6 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 
 	printk("one packet done!\n");
 
-	/* On success, increment avail index. */
-	vq->last_avail_idx++;
-
 	/* Assume notifications from guest are disabled at this point,
 	 * if they aren't we would need to update avail_event index. */
 	BUG_ON(!(vq->used_flags & VRING_USED_F_NO_NOTIFY));
@@ -2300,6 +2312,8 @@ EXPORT_SYMBOL_GPL(vhost_get_vq_desc);
 void vhost_discard_vq_desc(struct vhost_virtqueue *vq, int n)
 {
 	vq->last_avail_idx -= n;
+	printk("vq %p discard last_avail %d to %d\n",
+		vq, vq->last_avail_idx, n);
 }
 EXPORT_SYMBOL_GPL(vhost_discard_vq_desc);
 
@@ -2327,7 +2341,7 @@ static int __vhost_add_used_n(struct vhost_virtqueue *vq,
 	start = vq->last_used_idx & (vq->num - 1);
 	used = vq->used->ring + start;
 	if (count == 1) {
-		printk("add used %d to idx %d\n", heads[0].id, start);
+		printk("vq %p add used %d to idx %d\n", vq, heads[0].id, start);
 		if (vhost_put_user(vq, heads[0].id, &used->id)) {
 			vq_err(vq, "Failed to write used id");
 			return -EFAULT;
diff --git a/include/linux/virtio_net.h b/include/linux/virtio_net.h
index f144216..5498555 100644
--- a/include/linux/virtio_net.h
+++ b/include/linux/virtio_net.h
@@ -23,22 +23,28 @@ static inline int virtio_net_hdr_to_skb(struct sk_buff *skb,
 			gso_type = SKB_GSO_UDP;
 			break;
 		default:
+			printk("unknown gso type!\n");
 			return -EINVAL;
 		}
 
 		if (hdr->gso_type & VIRTIO_NET_HDR_GSO_ECN)
 			gso_type |= SKB_GSO_TCP_ECN;
 
-		if (hdr->gso_size == 0)
+		if (hdr->gso_size == 0) {
+			printk("gso size is zero!\n");
 			return -EINVAL;
+		}
 	}
 
 	if (hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {
 		u16 start = __virtio16_to_cpu(little_endian, hdr->csum_start);
 		u16 off = __virtio16_to_cpu(little_endian, hdr->csum_offset);
 
-		if (!skb_partial_csum_set(skb, start, off))
+		if (!skb_partial_csum_set(skb, start, off)) {
+			printk("partial csum set error skb->len %d "
+				"start %d off %d\n", skb->len, start, off);
 			return -EINVAL;
+		}
 	}
 
 	if (hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {
