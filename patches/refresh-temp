Bottom: c86a074bf72081c8dc9fc0985284e9e9759fef39
Top:    1bd5004fa8dc28957a12ee898146c01475658b33
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-09-30 17:01:13 +0800

Refresh of introduce-core-ring

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 696598c..3d57e22 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1300,8 +1300,7 @@ static unsigned int tun_chr_poll(struct file *file, poll_table *wait)
 
 	poll_wait(file, sk_sleep(sk), wait);
 
-	if (!ptr_ring_empty(&tfile->xdp_ring) ||
-	    !skb_array_empty(&tfile->tx_array))
+	if (!ptr_ring_empty(&tfile->xdp_ring))
 		mask |= POLLIN | POLLRDNORM;
 
 	if (tun->dev->flags & IFF_UP &&
@@ -2013,9 +2012,8 @@ static struct sk_buff *tun_ring_recv(struct tun_file *tfile, int noblock,
 
 static ssize_t tun_do_read(struct tun_struct *tun, struct tun_file *tfile,
 			   struct iov_iter *to,
-			   int noblock, struct sk_buff *skb)
+			   int noblock, struct xdp_buff *xdp)
 {
-	struct xdp_buff *xdp;
 	ssize_t ret;
 	int err;
 
@@ -2024,27 +2022,13 @@ static ssize_t tun_do_read(struct tun_struct *tun, struct tun_file *tfile,
 	if (!iov_iter_count(to))
 		return 0;
 
-	if (!skb) {
+	if (!xdp) {
 		xdp = ptr_ring_consume(&tfile->xdp_ring);
-		if (xdp) {
-			ret = tun_put_user_xdp(tun, tfile, xdp, to);
-			goto xdp_out;
-		}
-		/* Read frames from ring */
-		skb = tun_ring_recv(tfile, noblock, &err);
-		if (!skb)
-			return err;
+		if (!xdp)
+			return -EAGAIN;
 	}
 
-	ret = tun_put_user(tun, tfile, skb, to);
-	if (unlikely(ret < 0))
-		kfree_skb(skb);
-	else
-		consume_skb(skb);
-
-	return ret;
-
-xdp_out:
+	ret = tun_put_user_xdp(tun, tfile, xdp, to);
 	put_page(virt_to_head_page(xdp->data));
 	return ret;
 }
@@ -3163,8 +3147,7 @@ struct socket *tun_get_socket(struct file *file)
 	struct tun_file *tfile;
 	if (file->f_op != &tun_fops)
 		return ERR_PTR(-EINVAL);
-	tfile = file->private_data;
-	if (!tfile)
+	tfile = file->private_data;	if (!tfile)
 		return ERR_PTR(-EBADFD);
 	return &tfile->socket;
 }
@@ -3183,6 +3166,19 @@ struct skb_array *tun_get_skb_array(struct file *file)
 }
 EXPORT_SYMBOL_GPL(tun_get_skb_array);
 
+struct ptr_ring *tun_get_xdp_ring(struct file *file)
+{
+	struct tun_file *tfile;
+
+	if (file->f_op != &tun_fops)
+		return ERR_PTR(-EINVAL);
+	tfile = file->private_data;
+	if (!tfile)
+		return ERR_PTR(-EBADFD);
+	return &tfile->xdp_ring;
+}
+EXPORT_SYMBOL_GPL(tun_get_xdp_ring);
+
 module_init(tun_init);
 module_exit(tun_cleanup);
 MODULE_DESCRIPTION(DRV_DESCRIPTION);
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 6bfd906..51ce939 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -89,7 +89,7 @@ struct vhost_net_ubuf_ref {
 
 #define VHOST_RX_BATCH 64
 struct vhost_net_buf {
-	struct sk_buff **queue;
+	void **queue;
 	int tail;
 	int head;
 };
@@ -109,6 +109,7 @@ struct vhost_net_virtqueue {
 	 * Protected by vq mutex. Writers must also take device mutex. */
 	struct vhost_net_ubuf_ref *ubufs;
 	struct skb_array *rx_array;
+	struct ptr_ring *xdp_ring;
 	struct vhost_net_buf rxq;
 };
 
@@ -158,8 +159,8 @@ static int vhost_net_buf_produce(struct vhost_net_virtqueue *nvq)
 	struct vhost_net_buf *rxq = &nvq->rxq;
 
 	rxq->head = 0;
-	rxq->tail = skb_array_consume_batched(nvq->rx_array, rxq->queue,
-					      VHOST_RX_BATCH);
+	rxq->tail = ptr_ring_consume_batched(nvq->xdp_ring, rxq->queue,
+					     VHOST_RX_BATCH);
 	return rxq->tail;
 }
 
@@ -167,13 +168,21 @@ static void vhost_net_buf_unproduce(struct vhost_net_virtqueue *nvq)
 {
 	struct vhost_net_buf *rxq = &nvq->rxq;
 
-	if (nvq->rx_array && !vhost_net_buf_is_empty(rxq)) {
-		skb_array_unconsume(nvq->rx_array, rxq->queue + rxq->head,
-				    vhost_net_buf_get_size(rxq));
+	if (nvq->xdp_ring && !vhost_net_buf_is_empty(rxq)) {
+		ptr_ring_unconsume(nvq->xdp_ring, rxq->queue + rxq->head,
+				   vhost_net_buf_get_size(rxq), NULL);
 		rxq->head = rxq->tail = 0;
 	}
 }
 
+static int tun_xdp_peek_len(struct xdp_buff *xdp)
+{
+	if (likely(xdp))
+		return xdp->data_end - xdp->data;
+	else
+		return 0;
+}
+
 static int vhost_net_buf_peek(struct vhost_net_virtqueue *nvq)
 {
 	struct vhost_net_buf *rxq = &nvq->rxq;
@@ -185,7 +194,7 @@ static int vhost_net_buf_peek(struct vhost_net_virtqueue *nvq)
 		return 0;
 
 out:
-	return __skb_array_len_with_tag(vhost_net_buf_get_ptr(rxq));
+	return tun_xdp_peek_len(vhost_net_buf_get_ptr(rxq));
 }
 
 static void vhost_net_buf_init(struct vhost_net_buf *rxq)
@@ -586,12 +595,8 @@ static int peek_head_len(struct vhost_net_virtqueue *rvq, struct sock *sk)
 	struct sk_buff *head;
 	int len = 0;
 	unsigned long flags;
-	struct socket *sock = sk->sk_socket;
 
-	if (sock->ops->peek_len)
-		return sock->ops->peek_len(sock);
-
-	if (rvq->rx_array)
+	if (rvq->xdp_ring)
 		return vhost_net_buf_peek(rvq);
 
 	spin_lock_irqsave(&sk->sk_receive_queue.lock, flags);
@@ -786,7 +791,7 @@ static void handle_rx(struct vhost_net *net)
 		/* On error, stop handling until the next kick. */
 		if (unlikely(headcount < 0))
 			goto out;
-		if (nvq->rx_array)
+		if (nvq->xdp_ring)
 			msg.msg_control = vhost_net_buf_consume(&nvq->rxq);
 		/* On overrun, truncate and discard */
 		if (unlikely(headcount > UIO_MAXIOV)) {
@@ -904,7 +909,7 @@ static int vhost_net_open(struct inode *inode, struct file *f)
 	struct vhost_net *n;
 	struct vhost_dev *dev;
 	struct vhost_virtqueue **vqs;
-	struct sk_buff **queue;
+	void **queue;
 	int i;
 
 	n = kvmalloc(sizeof *n, GFP_KERNEL | __GFP_RETRY_MAYFAIL);
@@ -916,7 +921,7 @@ static int vhost_net_open(struct inode *inode, struct file *f)
 		return -ENOMEM;
 	}
 
-	queue = kmalloc_array(VHOST_RX_BATCH, sizeof(struct sk_buff *),
+	queue = kmalloc_array(VHOST_RX_BATCH, sizeof(void *),
 			      GFP_KERNEL);
 	if (!queue) {
 		kfree(vqs);
@@ -1073,6 +1078,23 @@ static struct skb_array *get_tap_skb_array(int fd)
 	return array;
 }
 
+static struct ptr_ring *get_tap_xdp_ring(int fd)
+{
+	struct ptr_ring *ring;
+	struct file *file = fget(fd);
+
+	if (!file)
+		return NULL;
+	ring = tun_get_xdp_ring(file);
+	if (!IS_ERR(ring))
+		goto out;
+	ring = NULL;
+
+out:
+	fput(file);
+	return ring;
+}
+
 static struct socket *get_tap_socket(int fd)
 {
 	struct file *file = fget(fd);
@@ -1150,8 +1172,10 @@ static long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)
 		vhost_net_disable_vq(n, vq);
 		vq->private_data = sock;
 		vhost_net_buf_unproduce(nvq);
-		if (index == VHOST_NET_VQ_RX)
+		if (index == VHOST_NET_VQ_RX) {
 			nvq->rx_array = NULL;
+			nvq->xdp_ring = get_tap_xdp_ring(fd);
+		}
 		r = vhost_vq_init_access(vq);
 		if (r)
 			goto err_used;
diff --git a/include/linux/if_tun.h b/include/linux/if_tun.h
index bf9bdf4..5665fb5 100644
--- a/include/linux/if_tun.h
+++ b/include/linux/if_tun.h
@@ -20,6 +20,7 @@
 #if defined(CONFIG_TUN) || defined(CONFIG_TUN_MODULE)
 struct socket *tun_get_socket(struct file *);
 struct skb_array *tun_get_skb_array(struct file *file);
+struct ptr_ring *tun_get_xdp_ring(struct file *file);
 #else
 #include <linux/err.h>
 #include <linux/errno.h>
@@ -33,5 +34,9 @@ static inline struct skb_array *tun_get_skb_array(struct file *f)
 {
 	return ERR_PTR(-EINVAL);
 }
+struct ptr_ring *tun_get_xdp_ring(struct file *f);
+{
+	return ERR_PTR(-EINVAL);
+}
 #endif /* CONFIG_TUN */
 #endif /* __IF_TUN_H */
