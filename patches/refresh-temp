Bottom: 947601849fbe471f52bd489382aa9a2b8e6ea3c0
Top:    347b4aa690ad566460537604fecf7b7e643a4ab2
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-09-16 08:42:56 +0800

Refresh of vhost_net-tweak-busy-polling

---

diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index e29150a..542f06a 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -110,6 +110,8 @@ struct vhost_net_virtqueue {
 	struct vhost_net_ubuf_ref *ubufs;
 	struct skb_array *rx_array;
 	struct vhost_net_buf rxq;
+	u64 sleep;
+	u64 wakeup;
 };
 
 struct vhost_net {
@@ -487,6 +489,7 @@ static void handle_tx(struct vhost_net *net)
 				vhost_disable_notify(&net->dev, vq);
 				continue;
 			}
+			nvq->sleep = ktime_get_ns();
 			break;
 		}
 		if (in) {
@@ -601,6 +604,25 @@ static int sk_has_rx_data(struct sock *sk)
 	return skb_queue_empty(&sk->sk_receive_queue);
 }
 
+static vhost_net_adjust_poll_ns(struct vhost_net_virtqueue *vq, bool has_buffer)
+{
+	if (!vq->busyloop_timeout)
+		return;
+
+	if (has_buffer) {
+		u64 gap = ktime_get_ns() - vq->last_sleep;
+		if (gap < vq->curr_busy_loop_timeout)
+			return;
+		if (gap > vq->busyloop_timeout)
+			vq->curr_busy_loop_timeout /= 2;
+		else if (gap > vq->curr_busyloop_timeout) {
+			vq->curr_busyloop_timeout *= 2;
+			if (vq->curr_busy_loop_timeout > vq->busyloop_timeout)
+				vq->curr_busyloop_timeout = vq->busyloop_timeout;
+		}
+	}
+}
+
 static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk)
 {
 	struct vhost_net_virtqueue *rvq = &net->vqs[VHOST_NET_VQ_RX];
@@ -639,6 +661,22 @@ static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk)
 		len = peek_head_len(rvq, sk);
 	}
 
+	if (vq->busyloop_timeout) {
+		if (len) {
+			u64 gap = ktime_get_ns() - nvq->sleep;
+			if (gap < vq->curr_busyloop_timeout)
+				;
+			else if (gap > vq->busyloop_timeout)
+				/* shirnk */;
+			else if (gap < vq->busyloop_timeout &&
+				gap > vq->curr_busyloop_tiemout) {
+				/* grow */;
+			}
+		}
+		else
+			nvq->sleep = ktime_get_ns();
+	}
+
 	return len;
 }
