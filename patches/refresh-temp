Bottom: 045df8079784064eaf2d20794ea3949899419a59
Top:    bce12ef21fe3ae5e4628f1e864a60b0c79209d9a
Author: Jason Wang <jasowang@redhat.com>
Date:   2015-06-25 17:33:44 +0800

Refresh of tun-rework-on-flow-cache

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index ea4ab5a..19da71f 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -215,11 +215,12 @@ static void tun_flow_delete_by_queue(struct tun_struct *tun, u16 queue_index)
 	}
 }
 
-static void tun_flow_update(struct tun_struct *tun, u32 rxhash,
-			    struct tun_file *tfile)
+static void tun_flow_update(struct tun_struct *tun,
+			    struct tun_file *tfile,
+			    u32 sw_hash)
 {
-	int index = rxhash & TUN_FLOW_MASK;
-	u32 val = (rxhash & ~TAP_QUEUE_MASK) | tfile->queue_index;
+	int index = sw_hash & TUN_FLOW_MASK;
+	u32 val = (sw_hash & ~TAP_QUEUE_MASK) | tfile->queue_index;
 
 	if (!rxhash)
 		return;
@@ -231,17 +232,17 @@ static void tun_flow_update(struct tun_struct *tun, u32 rxhash,
 
 static void tun_flow_rps_update(struct tun_struct *tun,
 				struct tun_file *tfile,
-				u32 hash)
+				u32 sw_hash, u32 hash)
 {
-	int index = hash & TUN_FLOW_MASK;
-	u32 val = (hash & ~TAP_QUEUE_MASK) | tfile->queue_index;
+	int index = sw_hash & TUN_FLOW_MASK;
+	u32 val = (sw_hash & ~TAP_QUEUE_MASK) | tfile->queue_index;
 
-	if (!hash)
+	if (!hash || !sw_hash) {
+		return;
+	} else if ((tun->flows[index].ent ^ sw_hash) & ~TAP_QUEUE_MASK)
 		return;
-	else if (tun->flows[index].ent == )
+	else
 		tun->flows[index].rps_hash = hash;
-
-	sock_rps_record_flow_hash(hash);
 }
 
 /* We try to identify a flow through its rxhash first. The reason that
@@ -255,20 +256,22 @@ static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb,
 			    void *accel_priv, select_queue_fallback_t fallback)
 {
 	struct tun_struct *tun = netdev_priv(dev);
-	u32 hash;
+	u32 hash, sw_hash;
 	u32 txq = 0;
 	u32 numqueues = 0;
-
 	rcu_read_lock();
 	numqueues = ACCESS_ONCE(tun->numqueues);
 
 	hash = skb_get_hash(skb);
-	if (hash) {
-		u32 ident = tun->flows[hash & TUN_FLOW_MASK].ent;
+	sw_hash = skb_get_sw_hash(skb);
+	tun_flow_rps_update(tun, tfile, sw_hash, hash);
 
-		if ((ident ^ hash) & ~TAP_QUEUE_MASK) {
+	if (sw_hash) {
+		u32 ident = tun->flows[sw_hash & TUN_FLOW_MASK].ent;
+
+		if ((ident ^ sw_hash) & ~TAP_QUEUE_MASK) {
 			/* use multiply and shift instead of expensive divide */
-			txq = ((u64)hash * numqueues) >> 32;
+			txq = ((u64)sw_hash * numqueues) >> 32;
 		} else
 			txq = ident & TAP_QUEUE_MASK;
 	} else if (likely(skb_rx_queue_recorded(skb))) {
@@ -632,6 +635,15 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 	if (txq >= numqueues)
 		goto drop;
 
+	if (numqueues == 1) {
+		u32 hash = skb_get_hash(skb);
+		u32 sw_hash = skb_get_sw_hash(skb);
+		/* Select queue was not called for the skbuff, so we extract the
+		 * RPS hash and save it into the flow_table here.
+		 */
+		tun_flow_rps_update(tun, tfile, sw_hash, hash);
+	}
+
 	tun_debug(KERN_INFO, tun, "tun_net_xmit %d\n", skb->len);
 
 	BUG_ON(!tfile);
@@ -881,7 +893,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	int copylen;
 	bool zerocopy = false;
 	int err;
-	u32 rxhash;
+	u32 sw_hash;
 	ssize_t n;
 
 	if (!(tun->flags & IFF_NO_PI)) {
@@ -1046,13 +1058,13 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	skb_reset_network_header(skb);
 	skb_probe_transport_header(skb, 0);
 
-	rxhash = skb_get_hash(skb);
+	sw_hash = skb_get_sw_hash(skb);
 	netif_rx_ni(skb);
 
 	tun->dev->stats.rx_packets++;
 	tun->dev->stats.rx_bytes += len;
 
-	tun_flow_update(tun, tfile, rxhash);
+	tun_flow_update(tun, tfile, sw_hash);
 	return total_len;
 }
 
@@ -1083,6 +1095,7 @@ static ssize_t tun_put_user(struct tun_struct *tun,
 	int vlan_offset = 0;
 	int vlan_hlen = 0;
 	int vnet_hdr_sz = 0;
+	u32 sw_hash;
 
 	if (skb_vlan_tag_present(skb))
 		vlan_hlen = VLAN_HLEN;
@@ -1179,7 +1192,8 @@ static ssize_t tun_put_user(struct tun_struct *tun,
 	skb_copy_datagram_iter(skb, vlan_offset, iter, skb->len - vlan_offset);
 
 done:
-	tun_flow_rps_update(tun, tfile, skb_get_hash(skb));
+	sw_hash = skb_get_sw_hash(sbk);
+	sock_rps_record_flow_hash(tun->flows[sw_hash & TUN_FLOW_MASK].rps_hash);
 	tun->dev->stats.tx_packets++;
 	tun->dev->stats.tx_bytes += skb->len + vlan_hlen;
