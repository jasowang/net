Bottom: 393a469e499e95a0fbc8eb22d6f1707bbb7053cb
Top:    1019ead928d36a3ae89b6c68f66aeace486eed6e
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-02-09 17:57:14 +0800

tun: fixes deadlock during resizing

Dmitry Vyukov report a deadlock below:

 Possible interrupt unsafe locking scenario:

       CPU0                    CPU1
       ----                    ----
  lock(&(&r->consumer_lock)->rlock);
                               local_irq_disable();
                               lock(&(&r->producer_lock)->rlock);
                               lock(&(&r->consumer_lock)->rlock);
  <Interrupt>
    lock(&(&r->producer_lock)->rlock);

This happens when CPU0's consuming were interrupted with producing
which CPU1 is doing resize. The problem is the different order of two
locks in two CPUs. To fixed this, using skb_array_consume_bh() to
avoid trying to hold producer_lock after held consumer_lock.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 8a7d6b9..a97c00d 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -520,7 +520,7 @@ static void tun_queue_purge(struct tun_file *tfile)
 {
 	struct sk_buff *skb;
 
-	while ((skb = skb_array_consume(&tfile->tx_array)) != NULL)
+	while ((skb = skb_array_consume_bh(&tfile->tx_array)) != NULL)
 		kfree_skb(skb);
 
 	skb_queue_purge(&tfile->sk.sk_write_queue);
@@ -1458,7 +1458,7 @@ static struct sk_buff *tun_ring_recv(struct tun_file *tfile, int noblock,
 	struct sk_buff *skb = NULL;
 	int error = 0;
 
-	skb = skb_array_consume(&tfile->tx_array);
+	skb = skb_array_consume_bh(&tfile->tx_array);
 	if (skb)
 		goto out;
 	if (noblock) {
@@ -1470,7 +1470,7 @@ static struct sk_buff *tun_ring_recv(struct tun_file *tfile, int noblock,
 	current->state = TASK_INTERRUPTIBLE;
 
 	while (1) {
-		skb = skb_array_consume(&tfile->tx_array);
+		skb = skb_array_consume_bh(&tfile->tx_array);
 		if (skb)
 			break;
 		if (signal_pending(current)) {
