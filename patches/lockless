Bottom: 85b36bd5eb3ef8e8cfe3ae3ddd45fbe6e2c19b0c
Top:    fcbaa04dc5199bdd3c49eac6e08963a7b6926b0e
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-05-06 03:34:40 -0400

lockless


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index c826c95..21910c9 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -175,10 +175,11 @@ struct tun_file {
 	struct list_head next;
 	struct tun_struct *detached;
 	spinlock_t rlock;
-	spinlock_t wlock;
-	struct tun_desc tx_descs[TUN_RING_SIZE];
 	unsigned short head;
+	struct tun_desc tx_descs[TUN_RING_SIZE];
+	spinlock_t wlock;
 	unsigned short tail;
+	unsigned short tail_shadow;
 };
 
 struct tun_flow_entry {
@@ -843,7 +844,7 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 	int txq = skb->queue_mapping;
 	struct tun_file *tfile;
 	u32 numqueues = 0;
-	unsigned long flags;
+	int this;
 
 	rcu_read_lock();
 	tfile = rcu_dereference(tun->tfiles[txq]);
@@ -914,12 +915,14 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 	if (((tfile->tail + 1) & TUN_RING_MASK) == tfile->head)
 		goto drop;
 
-	spin_lock_irqsave(&tfile->wlock, flags);
-	tfile->tx_descs[tfile->tail].skb = skb;
-	tfile->tx_descs[tfile->tail].len = skb->len;
+
+	this = (atomic_inc_short(&tfile->tail_shadow) - 1) & TUN_RING_MASK;
+	tfile->tx_descs[this].skb = skb;
+	tfile->tx_descs[this].len = skb->len;
 	smp_wmb();
+	while (unlikely(READ_ONCE(tfile->tail) != this))
+		cpu_relax();
 	tfile->tail = (tfile->tail + 1) & TUN_RING_MASK;
-	spin_unlock_irqrestore(&tfile->wlock, flags);
 
 	/* Notify and wake up reader process */
 	if (tfile->flags & TUN_FASYNC)
@@ -2390,6 +2393,7 @@ static int tun_chr_open(struct inode *inode, struct file * file)
 
 	sock_set_flag(&tfile->sk, SOCK_ZEROCOPY);
 	tfile->head = tfile->tail = 0;
+	tfile->tail_shadow = 0;
 
 	spin_lock_init(&tfile->rlock);
 	spin_lock_init(&tfile->wlock);
