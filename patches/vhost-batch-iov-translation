Bottom: 1f4f528788cab5d644bd344dd2456e0a2b3bd963
Top:    a7fa65dfb85c580263257d8c0108073ab6eac788
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-09-06 20:40:08 +0800

vhost: batch iov translation

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index acca816..9aef066 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -446,7 +446,7 @@ static void handle_tx(struct vhost_net *net)
 	struct vhost_virtqueue *vq = &nvq->vq;
 	struct vring_used_elem used, *heads = vq->heads;
 	unsigned out, in;
-	int avails, head;
+	int avails;
 	struct msghdr msg = {
 		.msg_name = NULL,
 		.msg_namelen = 0,
@@ -513,20 +513,29 @@ static void handle_tx(struct vhost_net *net)
 
 		for (i = 0; i < avails; i++) {
 			struct vring_desc *d = cont ? &vq->descs[i] : NULL;
-
-			head = __vhost_get_vq_desc(vq, vq->iov,
-						   ARRAY_SIZE(vq->iov),
-						   &out, &in, NULL, NULL, d,
-						   vhost16_to_cpu(vq, heads[i].id));
-			if (in) {
-				vq_err(vq, "Unexpected descriptor format for "
-					   "TX: out %d, int %d\n", out, in);
-				goto out;
+			__virtio16 head = vhost16_to_cpu(vq, heads[i].id);
+			int offset = 0;
+
+			if (!cont) {
+				head = __vhost_get_vq_desc(vq, vq->iov,
+							ARRAY_SIZE(vq->iov),
+							&out, &in, NULL, NULL,
+							d, head);
+
+				if (in) {
+					vq_err(vq, "Unexpected descriptor format for "
+						"TX: out %d, int %d\n", out, in);
+					goto out;
+				}
+			} else {
+				out = 1;
+				in = 0;
+				offset = i;
 			}
 
 			/* Skip header. TODO: support TSO. */
-			len = iov_length(vq->iov, out);
-			iov_iter_init(&msg.msg_iter, WRITE, vq->iov, out, len);
+			len = iov_length(vq->iov + offset, out);
+			iov_iter_init(&msg.msg_iter, WRITE, vq->iov + offset, out, len);
 			iov_iter_advance(&msg.msg_iter, hdr_size);
 			/* Sanity check */
 			if (!msg_data_left(&msg)) {
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 808469e..4f4c5aa 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -2514,6 +2514,8 @@ int vhost_prefetch_desc_indices(struct vhost_virtqueue *vq,
 		if (i > 0 && *cont && heads[i].id !=
 			((heads[i - 1].id + 1) & (vq->num - 1))) {
 			*cont = false;
+			printk("this %d prev %d\n", heads[i].id,
+				heads[i - 1].id);
 		}
 	}
 
@@ -2534,6 +2536,8 @@ int vhost_prefetch_desc_indices(struct vhost_virtqueue *vq,
 		total -= copied;
 	}
 
+	/* Only get avail ring entries after they have been exposed by guest. */
+	smp_rmb();
 
 	if (*cont) {
 		total = ret;
@@ -2553,8 +2557,35 @@ int vhost_prefetch_desc_indices(struct vhost_virtqueue *vq,
 		}
 	}
 
-	/* Only get avail ring entries after they have been exposed by guest. */
-	smp_rmb();
+	if (*cont) {
+		for (i = 0; i < ret; i++) {
+			u64 addr = vhost64_to_cpu(vq, descs[i].addr);
+			u64 len = vhost64_to_cpu(vq, descs[i].len);
+
+			if (next_desc(vq, &descs[i]) != -1 ||
+			    descs[i].flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT)) {
+				*cont = false;
+				printk("indir!\n");
+				break;
+			}
+			ret2 = translate_desc(vq, addr, len,
+					      vq->iov + i, UIO_MAXIOV - i,
+					      VHOST_ACCESS_RO);
+			if (unlikely(ret2 < 0)) {
+				vq_err(vq, "Translation failure\n");
+				return -EFAULT;
+			}
+			if (unlikely(ret2 != 1)) {
+				*cont = false;
+				printk("not one but %d\n", ret2);
+				break;
+			}
+			vq->last_avail_idx ++;
+		}
+	}
+
+	printk(" cont %d\n", *cont);
+
 	return ret;
 }
 EXPORT_SYMBOL(vhost_prefetch_desc_indices);
