Bottom: 236f0cca64c7e3f38022e525f4e23a140e358a8d
Top:    8bc594c1ff9b26446d7644731b1ba6da1c428bd5
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-07-17 13:40:53 +0800

virtnet: fix map fd during setup

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index ccc7f22..a43bf39 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1361,6 +1361,42 @@ static void __tun_xdp_flush_tfile(struct tun_file *tfile)
 	tfile->socket.sk->sk_data_ready(tfile->socket.sk);
 }
 
+static u32 tun_do_xdp_rx(struct tun_struct *tun, struct xdp_buff *xdp)
+{
+	struct bpf_prog *xdp_prog = rcu_dereference(tun->xdp_prog);
+	u32 act = XDP_PASS;
+
+	if (xdp_prog) {
+		act = bpf_prog_run_xdp(xdp_prog, xdp);
+		switch (act) {
+		case XDP_REDIRECT:
+			err = xdp_do_redirect(tun->dev, xdp, xdp_prog);
+			if (err)
+				goto err_redirect;
+			xdp_do_flush_map();
+			break;
+		case XDP_TX:
+			WARN_ON_ONCE("XDP_TX in XDP RX\n");
+			/* FIXME */
+			break;
+		case XDP_PASS:
+			WARN_ON_ONCE("XDP_PASS in XDP RX\n");
+			/* FXIME build_skb() */
+			break;
+		default:
+			bpf_warn_invalid_xdp_action(act);
+			/* fall through */
+		case XDP_ABORTED:
+			trace_xdp_exception(tun->dev, xdp_prog, act);
+			/* fall through */
+		case XDP_DROP:
+			goto err_xdp;
+		}
+	}
+
+	return act;
+}
+
 static u32 tun_do_xdp_offload(struct tun_struct *tun, struct xdp_frame *frame)
 {
 	struct tun_prog *xdp_prog;
@@ -1377,8 +1413,8 @@ static u32 tun_do_xdp_offload(struct tun_struct *tun, struct xdp_frame *frame)
 		act = bpf_prog_run_xdp(xdp_prog->prog, &xdp);
 		switch (act) {
 		case XDP_TX:
-			/* FIXME! */
-			break;
+			/* fall through */
+			
 		case XDP_PASS:
 			break;
 		case XDP_REDIRECT:
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 5ad4a14..4df94e6 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -2403,12 +2403,27 @@ static const struct file_operations virtnet_bpf_string_fops = {
 	.llseek = seq_lseek
 };
 
+static struct virtnet_bpf_map *virtnet_get_bpf_map(struct virtnet_info *vi,
+						   struct bpf_map *map)
+{
+	struct virtnet_bpf_map *virtnet_map;
+
+	list_for_each_entry(virtnet_map, &vi->map_list, l) {
+		if (&virtnet_map->offmap->map == map)
+			return virtnet_map;
+	}
+
+	return NULL;
+}
+
 static int virtnet_bpf_create_prog(struct virtnet_info *vi,
 				   struct bpf_prog *prog)
 {
 	struct virtnet_bpf_bound_prog *state;
 	size_t insn_len = prog->len * sizeof(struct bpf_insn);
 	char name[16];
+	int i;
+	int err = 0;
 
 	state = kzalloc(sizeof(*state) + insn_len, GFP_KERNEL);
 	if (!state)
@@ -2419,6 +2434,42 @@ static int virtnet_bpf_create_prog(struct virtnet_info *vi,
 	state->vi = vi;
 	state->prog = prog;
 	state->len = prog->len;
+
+	/* Replace map fd with host identitier. */
+	for (i = 0; i < state->len; i++) {
+		struct bpf_insn *insn = &state->insnsi[i];
+		struct virtnet_bpf_map *virtnet_map;
+		struct bpf_map *map;
+		struct fd f;
+
+		if (insn->code != (BPF_LD | BPF_IMM | BPF_DW))
+			continue;
+
+		printk("found map access at idx %d! fd %d\n", i, insn->imm);
+		f = fdget(insn->imm);
+		map = __bpf_map_get(f);
+		if (IS_ERR(map)) {
+			printk("fd %d is not pointing to valid bpf_map\n",
+				insn->imm);
+			err = -EINVAL;
+			goto err_replace;
+		}
+
+		printk("find fd %d in imm\n", insn->imm);
+		virtnet_map = virtnet_get_bpf_map(vi, map);
+		if (!virtnet_map) {
+			printk("could not get a offloaded map fd %d\n",
+				insn->imm);
+			err = -EINVAL;
+			goto err_replace;
+		}
+
+		printk("replace it with %d\n", virtnet_map->id);
+		insn->imm = virtnet_map->id;
+
+		fdput(f);
+	}
+
 	state->state = "verify";
 
 	/* Program id is not populated yet when we create the state. */
@@ -2439,18 +2490,10 @@ static int virtnet_bpf_create_prog(struct virtnet_info *vi,
 	prog->aux->offload->dev_priv = state;
 
 	return 0;
-}
-
-static struct virtnet_bpf_map *virtnet_get_bpf_map(struct virtnet_info *vi,
-						   struct bpf_map *map)
-{
-	struct virtnet_bpf_map *virtnet_map;
-
-	list_for_each_entry(virtnet_map, &vi->map_list, l) {
-		return virtnet_map;
-	}
 
-	return NULL;
+err_replace:
+	kfree(state);
+	return err;
 }
 
 static int
@@ -2459,7 +2502,6 @@ virtnet_bpf_verify_insn(struct bpf_verifier_env *env, int insn_idx,
 {
 	struct virtnet_bpf_bound_prog *state;
 	struct virtnet_info *vi;
-	int i;
 
 	state = env->prog->aux->offload->dev_priv;
 	vi = state->vi;
@@ -2470,45 +2512,6 @@ virtnet_bpf_verify_insn(struct bpf_verifier_env *env, int insn_idx,
 	if (insn_idx == env->prog->len - 1)
 		pr_vlog(env, "Hello from virtio-net!\n");
 
-	/* Replace map fd with host identitier. */
-	for (i = 0; i < state->len; i++) {
-		struct bpf_insn *insn = &state->insnsi[i];
-		struct virtnet_bpf_map *virtnet_map;
-		struct bpf_map *map;
-		struct fd f;
-
-		if (insn->code != (BPF_LD | BPF_IMM | BPF_DW))
-			continue;
-
-		printk("found map access at idx %d! fd %d\n", i, insn->imm);
-#if 0
-		f = fdget(insn->imm);
-		map = __bpf_map_get(f);
-		if (IS_ERR(map)) {
-			pr_vlog(env, "fd %d is not pointing to valid bpf_map\n",
-				insn->imm);
-			printk("fd %d is not pointing to valid bpf_map\n",
-				insn->imm);
-			return -EINVAL;
-		}
-#endif
-
-		printk("find fd %d in imm\n", insn->imm);
-		virtnet_map = virtnet_get_bpf_map(vi, map);
-		if (!virtnet_map) {
-			pr_vlog(env, "could not get a offloaded map fd %d\n",
-				insn->imm);
-			printk("could not get a offloaded map fd %d\n",
-				insn->imm);
-			return -EINVAL;
-		}
-
-		printk("replace it with %d\n", virtnet_map->id);
-		insn->imm = virtnet_map->id;
-
-//		fdput(f);
-	}
-
 	return 0;
 }
 
@@ -2819,13 +2822,16 @@ static int virtnet_bpf(struct net_device *dev, struct netdev_bpf *bpf)
 	int err;
 
 	switch (bpf->command) {
-	case BPF_OFFLOAD_VERIFIER_PREP:
+	case BPF_OFFLOAD_VERIFIER_SETUP:
 		if (!vi->bpf_bind_accept)
 			return -EOPNOTSUPP;
-
 		err = virtnet_bpf_create_prog(vi, bpf->verifier.prog);
 		if (err)
 			return err;
+		return 0;
+	case BPF_OFFLOAD_VERIFIER_PREP:
+		if (!vi->bpf_bind_accept)
+			return -EOPNOTSUPP;
 
 		bpf->verifier.ops = &virtnet_bpf_analyzer_ops;
 		return 0;
