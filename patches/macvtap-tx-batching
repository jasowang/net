Bottom: a4b273519593dd2321156b103734a2efce1828a1
Top:    95b738709159d4b1b7e2425ff9ce15d2e4edf930
Author: = <=>
Date:   2016-12-07 17:21:42 +0800

macvtap: tx batching

rx_batched=0 : 0.80Mpps
rx_batched=32: 1.09Mpps

Signed-off-by: = <=>


---

diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c
index 52a9d81..2235d9d 100644
--- a/drivers/net/macvtap.c
+++ b/drivers/net/macvtap.c
@@ -23,6 +23,10 @@
 #include <linux/virtio_net.h>
 #include <linux/skb_array.h>
 
+static int rx_batched = 0;
+module_param(rx_batched, int, 0444);
+MODULE_PARM_DESC(rx_batched, "Number of packets batched in rx");
+
 /*
  * A macvtap queue is the central object of this driver, it connects
  * an open character device to a macvlan interface. There can be
@@ -539,6 +543,7 @@ static void macvtap_sock_destruct(struct sock *sk)
 {
 	struct macvtap_queue *q = container_of(sk, struct macvtap_queue, sk);
 
+	skb_queue_purge(&sk->sk_write_queue);
 	skb_array_cleanup(&q->skb_array);
 }
 
@@ -660,12 +665,45 @@ static inline struct sk_buff *macvtap_alloc_skb(struct sock *sk, size_t prepad,
 	return skb;
 }
 
+static int macvtap_batch_xmit(struct macvtap_queue *q, struct sk_buff *skb,
+			      int more)
+{
+	struct sk_buff_head *queue = &q->sk.sk_write_queue;
+	struct sk_buff_head process_queue;
+	int qlen;
+	bool rcv = false;
+
+	spin_lock(&queue->lock);
+	qlen = skb_queue_len(queue);
+	if (qlen > rx_batched)
+		goto drop;
+	__skb_queue_tail(queue, skb);
+	if (!more || qlen + 1 > rx_batched) {
+		__skb_queue_head_init(&process_queue);
+		skb_queue_splice_tail_init(queue, &process_queue);
+		rcv = true;
+	}
+	spin_unlock(&queue->lock);
+
+	if (rcv) {
+		while ((skb = __skb_dequeue(&process_queue)))
+			dev_queue_xmit(skb);
+	}
+
+	return 0;
+drop:
+	spin_unlock(&queue->lock);
+	kfree_skb(skb);
+	return -EFAULT;
+}
+
 /* Neighbour code has some assumptions on HH_DATA_MOD alignment */
 #define MACVTAP_RESERVE HH_DATA_OFF(ETH_HLEN)
 
 /* Get packet from user space buffer */
 static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,
-				struct iov_iter *from, int noblock)
+				struct iov_iter *from, int noblock,
+				int more)
 {
 	int good_linear = SKB_MAX_HEAD(MACVTAP_RESERVE);
 	struct sk_buff *skb;
@@ -781,7 +819,11 @@ static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,
 
 	if (vlan) {
 		skb->dev = vlan->dev;
-		dev_queue_xmit(skb);
+
+		if (!rx_batched)
+			dev_queue_xmit(skb);
+		else
+			macvtap_batch_xmit(q, skb, more);
 	} else {
 		kfree_skb(skb);
 	}
@@ -807,7 +849,8 @@ static ssize_t macvtap_write_iter(struct kiocb *iocb, struct iov_iter *from)
 	struct file *file = iocb->ki_filp;
 	struct macvtap_queue *q = file->private_data;
 
-	return macvtap_get_user(q, NULL, from, file->f_flags & O_NONBLOCK);
+	return macvtap_get_user(q, NULL, from,
+				file->f_flags & O_NONBLOCK, false);
 }
 
 /* Put packet to the user space buffer */
@@ -1189,7 +1232,9 @@ static int macvtap_sendmsg(struct socket *sock, struct msghdr *m,
 			   size_t total_len)
 {
 	struct macvtap_queue *q = container_of(sock, struct macvtap_queue, sock);
-	return macvtap_get_user(q, m, &m->msg_iter, m->msg_flags & MSG_DONTWAIT);
+	return macvtap_get_user(q, m, &m->msg_iter,
+				m->msg_flags & MSG_DONTWAIT,
+				m->msg_flags & MSG_MORE);
 }
 
 static int macvtap_recvmsg(struct socket *sock, struct msghdr *m,
