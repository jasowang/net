Bottom: acfa1276cf27ff4a32a985709c5da64ac3220221
Top:    93f33124a9df5e450387a019e5f83f9f772c80d8
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-02-09 17:57:17 +0800

debug


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 0dc66e4..14ac8d7 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1119,6 +1119,7 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 	/* Notify and wake up reader process */
 	if (tfile->flags & TUN_FASYNC)
 		kill_fasync(&tfile->fasync, SIGIO, POLL_IN);
+	printk("wake up !\n");
 	tfile->socket.sk->sk_data_ready(tfile->socket.sk);
 
 	rcu_read_unlock();
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 9c3f816..7f05607 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -67,7 +67,8 @@ enum {
 	VHOST_NET_FEATURES = VHOST_FEATURES |
 			 (1ULL << VHOST_NET_F_VIRTIO_NET_HDR) |
 			 (1ULL << VIRTIO_NET_F_MRG_RXBUF) |
-			 (1ULL << VIRTIO_F_IOMMU_PLATFORM)
+			 (1ULL << VIRTIO_F_IOMMU_PLATFORM) |
+	                 (1ULL << VIRTIO_F_RING_PACKED)
 };
 
 enum {
@@ -482,6 +483,8 @@ static void handle_tx(struct vhost_net *net)
 	if (!vq_iotlb_prefetch(vq))
 		goto out;
 
+	printk("handle tx!\n");
+
 	vhost_disable_notify(&net->dev, vq);
 	vhost_net_disable_vq(net, vq);
 
@@ -586,6 +589,7 @@ static void handle_tx(struct vhost_net *net)
 		}
 	}
 out:
+	printk("tx done!\n");
 	mutex_unlock(&vq->mutex);
 }
 
@@ -781,6 +785,7 @@ static void handle_rx(struct vhost_net *net)
 		vq->log : NULL;
 	mergeable = vhost_has_feature(vq, VIRTIO_NET_F_MRG_RXBUF);
 
+	printk("handle rx!\n");
 	while ((sock_len = vhost_net_rx_peek_head_len(net, sock->sk))) {
 		sock_len += sock_hlen;
 		vhost_len = sock_len + vhost_hlen;
@@ -872,6 +877,7 @@ static void handle_rx(struct vhost_net *net)
 	}
 	vhost_net_enable_vq(net, vq);
 out:
+	printk("rx done!\n");
 	if (nheads)
 		vhost_add_used_and_signal_n(&net->dev, vq, vq->heads,
 					    nheads);
@@ -1267,6 +1273,12 @@ static int vhost_net_set_features(struct vhost_net *n, u64 features)
 			goto out_unlock;
 	}
 
+	if (features & (1ULL << VIRTIO_F_RING_PACKED)) {
+		dump_stack();
+		printk("packed ring!\n");
+	} else
+		printk("split ring!\n");
+
 	for (i = 0; i < VHOST_NET_VQ_MAX; ++i) {
 		mutex_lock(&n->vqs[i].vq.mutex);
 		n->vqs[i].vq.acked_features = features;
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 52e026a..88b4c05 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -327,7 +327,7 @@ static void vhost_vq_reset(struct vhost_dev *dev,
 	vhost_reset_is_le(vq);
 	vhost_disable_cross_endian(vq);
 	vq->busyloop_timeout = 0;
-	vq->used_warp_counter = false;
+	vq->used_wrap_counter = false;
 	vq->umem = NULL;
 	vq->iotlb = NULL;
 	__vhost_vq_meta_reset(vq);
@@ -2013,8 +2013,21 @@ static int get_indirect(struct vhost_virtqueue *vq,
 static bool desc_is_avail(struct vhost_virtqueue *vq,
 			  struct vring_desc_packed *desc)
 {
+	if (vq->used_wrap_counter) {
+		if ((desc->flags & VRING_DESC_F_AVAIL) &&
+		   !(desc->flags & VRING_DESC_F_USED))
+			return true;
+	} else {
+		if (!(desc->flags & VRING_DESC_F_AVAIL) &&
+		     (desc->flags & VRING_DESC_F_USED))
+			return true;
+	}
+	return false;
+
+#if 0
 	return ((desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_AVAIL)) ^
 		(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_USED)));
+#endif
 }
 
 static void set_desc_used(struct vhost_virtqueue *vq,
@@ -2044,8 +2057,11 @@ static int vhost_get_vq_desc_packed(struct vhost_virtqueue *vq,
 	if (unlikely(log))
 		*log_num = 0;
 
+	printk("vq %p last avail %u vq->num %d \n", vq,
+		vq->last_avail_idx, vq->num);
 	do {
 		i = vq->last_avail_idx & (vq->num - 1);
+		printk("vq %p idx at %d\n", vq, i);
 		ret = vhost_copy_from_user(vq, &desc, vq->desc_packed + i,
 					   sizeof desc);
 		if (unlikely(ret)) {
@@ -2065,6 +2081,7 @@ static int vhost_get_vq_desc_packed(struct vhost_virtqueue *vq,
 			 * invalid.
 			 */
 			if (likely(avail_idx == vq->last_avail_idx)) {
+				printk("no new!\n");
 				return vq->num;
 			} else {
 				vq_err(vq, "descriptor idx %d is expected "
@@ -2117,6 +2134,7 @@ static int vhost_get_vq_desc_packed(struct vhost_virtqueue *vq,
 	/* If this descriptor says it doesn't chain, we're done. */
 	} while(desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT));
 
+	printk("vq %p desc.id is %d\n", vq, desc.id);
 	return desc.id;
 }
 
@@ -2360,12 +2378,14 @@ static int vhost_add_used_n_packed(struct vhost_virtqueue *vq,
 	for (i = 0; i < count; i++) {
 		desc.id = heads[i].id;
 		desc.len = heads[i].len;
-		set_desc_used(vq, &desc, vq->used_warp_counter);
+		set_desc_used(vq, &desc, vq->used_wrap_counter);
 
 		/* Update flags etc before desc is written */
 		smp_mb();
 
 		used_idx = vq->last_used_idx & (vq->num - 1);
+		printk("vq %p update used idx at %d id %d len %d\n",
+			vq, used_idx, desc.id, desc.len);
 		ret = vhost_copy_to_user(vq, vq->desc_packed + used_idx,
 					&desc, sizeof desc);
 		if (unlikely(ret)) {
@@ -2383,7 +2403,7 @@ static int vhost_add_used_n_packed(struct vhost_virtqueue *vq,
 				eventfd_signal(vq->log_ctx, 1);
 		}
 		if ((++vq->last_used_idx & (vq->num - 1)) == 0)
-			vq->used_warp_counter ^= 1;
+			vq->used_wrap_counter ^= 1;
 	}
 
 	return 0;
diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h
index c68bbfb..93f694a 100644
--- a/drivers/vhost/vhost.h
+++ b/drivers/vhost/vhost.h
@@ -153,7 +153,7 @@ struct vhost_virtqueue {
 	bool user_be;
 #endif
 	u32 busyloop_timeout;
-	bool used_warp_counter;
+	bool used_wrap_counter;
 };
 
 struct vhost_msg_node {
@@ -229,6 +229,7 @@ ssize_t vhost_chr_write_iter(struct vhost_dev *dev,
 			     struct iov_iter *from);
 int vhost_init_device_iotlb(struct vhost_dev *d, bool enabled);
 
+#define DEBUG
 #define vq_err(vq, fmt, ...) do {                                  \
 		pr_debug(pr_fmt(fmt), ##__VA_ARGS__);       \
 		if ((vq)->error_ctx)                               \
