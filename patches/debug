Bottom: ea0e8c72d068f33300d94762d6103a465ca589c4
Top:    63b6aa6e76e9727c7aa4d5bb0dc821b4ba146eb4
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-07-05 11:13:37 +0800

debug


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 7475215..1b253ac 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1206,9 +1206,17 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 			return -EFAULT;
 
 		if ((gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&
-		    tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2 > tun16_to_cpu(tun, gso.hdr_len))
+		    tun16_to_cpu(tun, gso.csum_start) +
+		    tun16_to_cpu(tun, gso.csum_offset) + 2 >
+			tun16_to_cpu(tun, gso.hdr_len)) {
+			if (!gso.csum_start || !gso.csum_offset)
+				printk("csum start %d csum offset %d hdr_len %d\n", tun16_to_cpu(tun, gso.csum_start),
+				tun16_to_cpu(tun, gso.csum_offset),
+				tun16_to_cpu(tun, gso.hdr_len));
 			gso.hdr_len = cpu_to_tun16(tun, tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2);
-
+			if (!gso.csum_start || !gso.csum_offset)
+				printk("adjusted %d\n", tun16_to_cpu(tun, gso.hdr_len));
+		}
 		if (tun16_to_cpu(tun, gso.hdr_len) > len)
 			return -EINVAL;
 		iov_iter_advance(from, tun->vnet_hdr_sz - sizeof(gso));
@@ -1217,8 +1225,12 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	if ((tun->flags & TUN_TYPE_MASK) == IFF_TAP) {
 		align += NET_IP_ALIGN;
 		if (unlikely(len < ETH_HLEN ||
-			     (gso.hdr_len && tun16_to_cpu(tun, gso.hdr_len) < ETH_HLEN)))
+			     (gso.hdr_len && tun16_to_cpu(tun,
+						     gso.hdr_len) <
+		ETH_HLEN))) {
+			printk("[tun] hdr len is %d\n", gso.hdr_len);
 			return -EINVAL;
+		}
 	}
 
 	good_linear = SKB_MAX_HEAD(align);
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 1dd08d4..fd38898 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -823,6 +823,7 @@ static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 	unsigned num_sg;
 	unsigned hdr_len = vi->hdr_len;
 	bool can_push;
+	int ret;
 
 	pr_debug("%s: xmit %p %pM\n", vi->dev->name, skb, dest);
 
@@ -843,6 +844,13 @@ static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 	if (vi->mergeable_rx_bufs)
 		hdr->num_buffers = 0;
 
+	if (hdr->hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM &&
+		(!hdr->hdr.csum_start || !hdr->hdr.csum_offset)) {
+		printk("csum start %d csum offset %d\n",
+			hdr->hdr.csum_start, hdr->hdr.csum_offset);
+		dump_stack();
+	}
+
 	sg_init_table(sq->sg, skb_shinfo(skb)->nr_frags + (can_push ? 1 : 2));
 	if (can_push) {
 		__skb_push(skb, hdr_len);
@@ -853,7 +861,14 @@ static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 		sg_set_buf(sq->sg, hdr, hdr_len);
 		num_sg = skb_to_sgvec(skb, sq->sg + 1, 0, skb->len) + 1;
 	}
-	return virtqueue_add_outbuf(sq->vq, sq->sg, num_sg, skb, GFP_ATOMIC);
+	ret = virtqueue_add_outbuf(sq->vq, sq->sg, num_sg, skb, GFP_ATOMIC);
+	if (hdr->hdr.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM &&
+		(!hdr->hdr.csum_start || !hdr->hdr.csum_offset)) {
+		printk("2! csum start %d csum offset %d\n",
+			hdr->hdr.csum_start, hdr->hdr.csum_offset);
+		dump_stack();
+	}
+	return ret;
 }
 
 static netdev_tx_t start_xmit(struct sk_buff *skb, struct net_device *dev)
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index e032ca3..49f6216 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -371,6 +371,7 @@ static void handle_tx(struct vhost_net *net)
 	struct socket *sock;
 	struct vhost_net_ubuf_ref *uninitialized_var(ubufs);
 	bool zcopy, zcopy_used;
+	ssize_t n;
 
 	mutex_lock(&vq->mutex);
 	sock = vq->private_data;
@@ -383,6 +384,7 @@ static void handle_tx(struct vhost_net *net)
 	zcopy = nvq->ubufs;
 
 	for (;;) {
+		struct iov_iter tmp;
 		/* Release DMAs done buffers first */
 		if (zcopy)
 			vhost_zerocopy_signal_used(net, vq);
@@ -416,6 +418,30 @@ static void handle_tx(struct vhost_net *net)
 		/* Skip header. TODO: support TSO. */
 		len = iov_length(vq->iov, out);
 		iov_iter_init(&msg.msg_iter, WRITE, vq->iov, out, len);
+		iov_iter_init(&tmp, WRITE, vq->iov, out, len);
+		{
+			struct virtio_net_hdr gso = { 0 };
+			n = copy_from_iter(&gso, sizeof(gso), &tmp);
+			if (gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM &&
+				(!gso.csum_start || !gso.csum_offset)) {
+				printk("start %d offset %d hdr_len %d\n",
+					vhost16_to_cpu(vq,
+						gso.csum_start),
+					vhost16_to_cpu(vq,
+						gso.csum_offset),
+					vhost16_to_cpu(vq,
+						gso.hdr_len));
+			}
+			if (n != sizeof(gso))
+				printk("header error!\n");
+			if (gso.hdr_len && vhost16_to_cpu(vq,
+						gso.hdr_len) < ETH_HLEN)
+				printk("error %d\n",
+					vhost16_to_cpu(vq,
+						gso.hdr_len));
+		}
+		if (hdr_size)
+			printk("advanced!\n");
 		iov_iter_advance(&msg.msg_iter, hdr_size);
 		/* Sanity check */
 		if (!msg_data_left(&msg)) {
diff --git a/include/linux/virtio_net.h b/include/linux/virtio_net.h
index 7a6c955..1c912f8 100644
--- a/include/linux/virtio_net.h
+++ b/include/linux/virtio_net.h
@@ -91,8 +91,6 @@ static inline int virtio_net_hdr_from_skb(const struct sk_buff *skb,
 				skb_checksum_start_offset(skb));
 		hdr->csum_offset = __cpu_to_virtio16(little_endian,
 				skb->csum_offset);
-                if (!hdr->csum_start || !hdr->csum_offset)
-                  dump_stack();
 	} else if (skb->ip_summed == CHECKSUM_UNNECESSARY) {
 		hdr->flags = VIRTIO_NET_HDR_F_DATA_VALID;
 	} /* else everything is zero */
