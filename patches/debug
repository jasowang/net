Bottom: e8b02f669338a20b62a01e695ac4ec1db4eb8eae
Top:    3274db35d47c5c8ee3315b6b1f1e45d60db832f3
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-01-24 16:18:03 +0800

debug


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 6988746..ec03caf 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1753,27 +1753,36 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	if (tun->flags & IFF_VNET_HDR) {
 		int vnet_hdr_sz = READ_ONCE(tun->vnet_hdr_sz);
 
-		if (len < vnet_hdr_sz)
+		if (len < vnet_hdr_sz) {
+			printk("tun vnet hdr sz!\n");
 			return -EINVAL;
+		}
 		len -= vnet_hdr_sz;
 
-		if (!copy_from_iter_full(&gso, sizeof(gso), from))
+		if (!copy_from_iter_full(&gso, sizeof(gso), from)) {
+			printk("tun gso !\n");
 			return -EFAULT;
+		}
 
 		if ((gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&
 		    tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2 > tun16_to_cpu(tun, gso.hdr_len))
 			gso.hdr_len = cpu_to_tun16(tun, tun16_to_cpu(tun, gso.csum_start) + tun16_to_cpu(tun, gso.csum_offset) + 2);
 
-		if (tun16_to_cpu(tun, gso.hdr_len) > len)
+		if (tun16_to_cpu(tun, gso.hdr_len) > len) {
+			printk("tun hdr len\n");
 			return -EINVAL;
+		}
 		iov_iter_advance(from, vnet_hdr_sz - sizeof(gso));
 	}
 
 	if ((tun->flags & TUN_TYPE_MASK) == IFF_TAP) {
 		align += NET_IP_ALIGN;
 		if (unlikely(len < ETH_HLEN ||
-			     (gso.hdr_len && tun16_to_cpu(tun, gso.hdr_len) < ETH_HLEN)))
+				(gso.hdr_len && tun16_to_cpu(tun,
+		gso.hdr_len) < ETH_HLEN))){
+			printk("tun hdr check!\n");
 			return -EINVAL;
+		}
 	}
 
 	good_linear = SKB_MAX_HEAD(align);
@@ -1802,10 +1811,13 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 		skb = tun_build_skb(tun, tfile, from, &gso, len, &skb_xdp);
 		if (IS_ERR(skb)) {
 			this_cpu_inc(tun->pcpu_stats->rx_dropped);
+			printk("tun can't build!\n");
 			return PTR_ERR(skb);
 		}
-		if (!skb)
+		if (!skb) {
+			printk("tun sbk NULL!\n");
 			return total_len;
+		}
 	} else {
 		if (!zerocopy) {
 			copylen = len;
@@ -1833,6 +1845,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 				this_cpu_inc(tun->pcpu_stats->rx_dropped);
 			if (frags)
 				mutex_unlock(&tfile->napi_mutex);
+			printk("tun skb err!\n");
 			return PTR_ERR(skb);
 		}
 
@@ -1849,6 +1862,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 				mutex_unlock(&tfile->napi_mutex);
 			}
 
+			printk("tun copy err!\n");
 			return -EFAULT;
 		}
 	}
@@ -1861,6 +1875,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 			mutex_unlock(&tfile->napi_mutex);
 		}
 
+		printk("tun vnet hdr conversion!\n");
 		return -EINVAL;
 	}
 
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 7baa90a..ccee3a0 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -576,7 +576,7 @@ static void handle_tx(struct vhost_net *net)
 			pr_debug("Truncated TX packet: "
 				 " len %d != %zd\n", err, len);
 		if (!zcopy_used)
-			vhost_add_used_and_signal(&net->dev, vq, head, 0);
+			vhost_add_used_and_signal(&net->dev, vq, head,	0);
 		else
 			vhost_zerocopy_signal_used(net, vq);
 		vhost_net_tx_packet(net);
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 0b19845..baf65cd 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -1997,11 +1997,18 @@ static int vhost_read_indices(struct vhost_virtqueue *vq, u16 num)
 	int ret, ret2;
 	int i;
 
-	BUG_ON(indices->read_tail != indices->tail);
+	//BUG_ON(indices->read_tail != indices->tail);
+	printk("vq %p read indices tail %d read_tail %d head %d\n",
+		vq, indices->tail, indices->read_tail, indices->head);
+	if (indices->read_tail != indices->tail)
+		printk("BUG vq %p read_tail is not equal to tail\n", vq);
 
+	printk("vq %p last_avail is %d\n", vq, vq->last_avail_idx);
 	if (unlikely(vhost_get_avail(vq, avail_idx, &vq->avail->idx))) {
 		vq_err(vq, "Failed to access avail idx at %p\n",
 		       &vq->avail->idx);
+		printk("vq %p Failed to access avail idx at %p\n",
+			vq, &vq->avail->idx);
 		return -EFAULT;
 	}
 	last_avail_idx = vq->last_avail_idx & (vq->num - 1);
@@ -2013,21 +2020,33 @@ static int vhost_read_indices(struct vhost_virtqueue *vq, u16 num)
 		ret2 = vhost_get_avail(vq, heads[i],
 				      &vq->avail->ring[last_avail_idx]);
 		if (unlikely(ret2)) {
+			printk("Failed to get descriptor\n");
 			vq_err(vq, "Failed to get descriptors\n");
 			return -EFAULT;
 		}
 		if (unlikely(heads[i] >= vq->num)) {
 			vq_err(vq, "Guest says index %u > %u is available",
 			       heads[i], vq->num);
+			printk("Guest says index %u > %u is available",
+			       heads[i], vq->num);
 			return -EINVAL;
 		}
+		printk("vq %p head %d offset %d last %d\n",
+			vq, heads[i], i, last_avail_idx);
 		last_avail_idx = (last_avail_idx + 1) & (vq->num - 1);
 	}
 
+	vq->last_avail_idx += ret;
+	printk("vq %p total %d last_avail_idx %d\n", vq, ret,
+		vq->last_avail_idx);
+
 	/* Only get avail ring entries after they have been exposed by guest. */
 	smp_rmb();
 	indices->head = ret;
 	indices->tail = indices->read_tail = 0;
+
+	printk("vq %p indices head %d tail %d\n",
+		vq, indices->head, indices->tail);
 	return ret;
 }
 
@@ -2036,12 +2055,17 @@ static int vhost_read_descs(struct vhost_virtqueue *vq, int num)
 	struct vhost_indices *indices = &vq->indices;
 	struct vhost_descs *descs = &vq->descs;
 	struct vring_desc *desc = &descs->last_desc;
-	__virtio16 head;
+	int head;
 	int ret;
+	int loop = 0;
 
 	descs->head = descs->tail = 0;
 
-	while ((head = next_desc(vq, desc)) != -1 && descs->head < num) {
+	head = next_desc(vq, desc);
+	printk("vq %p, last desc flags %d avail %d\n", vq, desc->flags, head);
+
+	while (((head = next_desc(vq, desc)) != -1) && (descs->head < num)) {
+		printk("vq %p continue read desc %d\n", vq, head);
 		desc = &descs->descs[descs->head];
 		ret = vhost_copy_from_user(vq, desc,
 					   vq->desc + head,
@@ -2050,6 +2074,9 @@ static int vhost_read_descs(struct vhost_virtqueue *vq, int num)
 			vq_err(vq, "Failed to get descriptor: "
 				"idx %d addr %p\n",
 				head, vq->desc + head);
+			printk("vq %p Failed to get descriptor: "
+				"idx %d addr %p\n",
+				vq, head, vq->desc + head);
 			goto err;
 		}
 		descs->head++;
@@ -2060,14 +2087,19 @@ static int vhost_read_descs(struct vhost_virtqueue *vq, int num)
 		return 0;
 	}
 
-	if (unlikely(indices->head == indices->tail) ||
-	    unlikely(vhost_read_indices(vq, num) < 0))
-		goto err;
+	printk("vq %p indices head %d indices tail %d\n",
+		vq, indices->head, indices->tail);
 
 	descs->last_desc.flags = 0;
+	printk("vq %p want to read desc from indices tail %d head %d\n",
+		vq, indices->tail, indices->head);
 	while (indices->tail < indices->head) {
+		printk("vq %p reading descs for indices tail %d\n",
+			vq, indices->tail);
 		head = vhost16_to_cpu(vq, indices->indices[indices->tail++]);
 		while(1) {
+			printk("vq %p read desc to descs head %d\n",
+				vq, descs->head);
 			desc = &descs->descs[descs->head];
 			ret = vhost_copy_from_user(vq, desc,
 						   vq->desc + head,
@@ -2076,6 +2108,10 @@ static int vhost_read_descs(struct vhost_virtqueue *vq, int num)
 				vq_err(vq, "Failed to get descriptor: "
 					   "idx %d addr %p\n",
 					   head, vq->desc + head);
+
+				printk("vq %p Failed to get descriptor: "
+					"idx %d addr %p\n",
+					vq, head, vq->desc + head);
 				goto err;
 			}
 
@@ -2087,7 +2123,12 @@ static int vhost_read_descs(struct vhost_virtqueue *vq, int num)
 
 			head = next_desc(vq, desc);
 			if (head == -1)
-				goto done;
+				break;
+			if (loop++ > 64) {
+				printk("Dead loop!\n");
+				ret = -EFAULT;
+				goto err;
+			}
 		}
 	}
 
@@ -2104,18 +2145,42 @@ static struct vring_desc *vhost_next_desc(struct vhost_virtqueue *vq,
 {
 	struct vhost_descs *descs = &vq->descs;
 	struct vhost_indices *indices = &vq->indices;
+	struct vring_desc *desc;
+	int ret;
 
+	if (indices->read_tail == indices->head) {
+		ret = vhost_read_indices(vq, 64);
+		if (unlikely(ret < 0)) {
+			printk("vq %p fail to read indices!\n", vq);
+			return ERR_PTR(-EFAULT);
+		}
+		if (ret == 0)
+			return NULL;
+	}
+
+	/* When reached here, we're sure we have indices cached */
 	if (descs->tail == descs->head) {
-		int ret = vhost_read_descs(vq, 64);
-		if (ret)
+		ret = vhost_read_descs(vq, 64);
+		if (ret) {
+			printk("vq %p fail to read descs!\n", vq);
 			return ERR_PTR(-EFAULT);
-		if (descs->tail == descs->head)
+		}
+		if (descs->tail == descs->head) {
+			printk("BUG: vq %p no new heads but indices!\n", vq);
 			return NULL;
+		}
 	}
 
-	if (advance)
+	if (advance) {
+		printk("vq %p adv read tail is %d head %d\n",
+			vq, indices->read_tail, indices->head);
 		*head = indices->indices[indices->read_tail++];
-	return &descs->descs[descs->tail++];
+	}
+
+	desc = &descs->descs[descs->tail++];
+	printk("vq %p advance %d desc %p head %d\n",
+		vq, advance, desc, *head);
+	return desc;
 }
 
 /* This looks in the virtqueue and for the first available buffer, and converts
@@ -2141,10 +2206,14 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 	/* If there's nothing new since last we looked, return
 	 * invalid.
 	 */
-	if (desc == NULL)
+	if (desc == NULL) {
+		printk("vq %p nothing new!\n", vq);
 		return vq->num;
-	if (IS_ERR(desc))
+	}
+	if (IS_ERR(desc)) {
+		printk("vq %p desc err!\n", vq);
 		return -EFAULT;
+	}
 
 	head = vhost16_to_cpu(vq, ring_head);
 
@@ -2157,6 +2226,7 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 		unsigned iov_count = *in_num + *out_num;
 
 		if (unlikely(++found > vq->num)) {
+			printk("vq %p loop detected!\n", vq);
 			vq_err(vq, "Loop detected: vq size %u head %u\n",
 			       vq->num, head);
 			return -EINVAL;
@@ -2166,6 +2236,7 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 					   out_num, in_num,
 					   log, log_num, desc);
 			if (unlikely(ret < 0)) {
+				printk("vq %p indirect fail!\n", vq);
 				if (ret != -EAGAIN)
 					vq_err(vq, "Failure detected "
 						"in indirect descriptor");
@@ -2183,11 +2254,14 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 				     iov + iov_count,
 				     iov_size - iov_count, access);
 		if (unlikely(ret < 0)) {
-			if (ret != -EAGAIN)
+			if (ret != -EAGAIN) {
+				printk("vq %p translation failure!\n",vq);
 				vq_err(vq, "Translation failure %d descriptor "
 					   "idx\n", ret);
+			}
 			return ret;
-		}
+		} else
+			printk("vq %p translation succeed!\n", vq);
 		if (access == VHOST_ACCESS_WO) {
 			/* If this is an input descriptor,
 			 * increment that count. */
@@ -2203,15 +2277,19 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			/* If it's an output descriptor, they're all supposed
 			 * to come before any input descriptors. */
 			if (unlikely(*in_num)) {
+				printk("vq %p out after in!\n", vq);
 				vq_err(vq, "Descriptor has out after in\n");
 				return -EINVAL;
 			}
 			*out_num += ret;
 		}
-	} while(!IS_ERR_OR_NULL(desc = vhost_next_desc(vq, &ring_head, false)));
+		if (next_desc(vq, desc) == -1)
+			break;
+		desc = vhost_next_desc(vq, &ring_head, false);
+		printk("next dest ? %d \n", IS_ERR_OR_NULL(desc));
+	} while(!IS_ERR_OR_NULL(desc));
 
-	/* On success, increment avail index. */
-	vq->last_avail_idx++;
+	printk("one packet done!\n");
 
 	/* Assume notifications from guest are disabled at this point,
 	 * if they aren't we would need to update avail_event index. */
@@ -2224,6 +2302,8 @@ EXPORT_SYMBOL_GPL(vhost_get_vq_desc);
 void vhost_discard_vq_desc(struct vhost_virtqueue *vq, int n)
 {
 	vq->last_avail_idx -= n;
+	printk("vq %p discard last_avail %d to %d\n",
+		vq, vq->last_avail_idx, n);
 }
 EXPORT_SYMBOL_GPL(vhost_discard_vq_desc);
 
@@ -2251,6 +2331,7 @@ static int __vhost_add_used_n(struct vhost_virtqueue *vq,
 	start = vq->last_used_idx & (vq->num - 1);
 	used = vq->used->ring + start;
 	if (count == 1) {
+		printk("vq %p add used %d to idx %d\n", vq, heads[0].id, start);
 		if (vhost_put_user(vq, heads[0].id, &used->id)) {
 			vq_err(vq, "Failed to write used id");
 			return -EFAULT;
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index eb30f3e..2d9e93c 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -319,6 +319,8 @@ static inline int virtqueue_add(struct virtqueue *_vq,
 		indirect = false;
 		desc = vq->vring.desc;
 		i = head;
+		if (_vq->index == 1)
+			printk("add %d\n", i);
 		descs_used = total_sg;
 	}
 
@@ -726,6 +728,8 @@ void *virtqueue_get_buf_ctx(struct virtqueue *_vq, unsigned int *len,
 	i = virtio32_to_cpu(_vq->vdev, vq->vring.used->ring[last_used].id);
 	*len = virtio32_to_cpu(_vq->vdev, vq->vring.used->ring[last_used].len);
 
+	if (_vq->index == 1)
+		printk("get %d from %d\n", i, last_used);
 	if (unlikely(i >= vq->vring.num)) {
 		BAD_RING(vq, "id %u out of range\n", i);
 		return NULL;
diff --git a/include/linux/virtio_net.h b/include/linux/virtio_net.h
index f144216..5498555 100644
--- a/include/linux/virtio_net.h
+++ b/include/linux/virtio_net.h
@@ -23,22 +23,28 @@ static inline int virtio_net_hdr_to_skb(struct sk_buff *skb,
 			gso_type = SKB_GSO_UDP;
 			break;
 		default:
+			printk("unknown gso type!\n");
 			return -EINVAL;
 		}
 
 		if (hdr->gso_type & VIRTIO_NET_HDR_GSO_ECN)
 			gso_type |= SKB_GSO_TCP_ECN;
 
-		if (hdr->gso_size == 0)
+		if (hdr->gso_size == 0) {
+			printk("gso size is zero!\n");
 			return -EINVAL;
+		}
 	}
 
 	if (hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {
 		u16 start = __virtio16_to_cpu(little_endian, hdr->csum_start);
 		u16 off = __virtio16_to_cpu(little_endian, hdr->csum_offset);
 
-		if (!skb_partial_csum_set(skb, start, off))
+		if (!skb_partial_csum_set(skb, start, off)) {
+			printk("partial csum set error skb->len %d "
+				"start %d off %d\n", skb->len, start, off);
 			return -EINVAL;
+		}
 	}
 
 	if (hdr->gso_type != VIRTIO_NET_HDR_GSO_NONE) {
