Bottom: c32b7acc311b4ad3de023cac19244ee526bc1587
Top:    bce12ef21fe3ae5e4628f1e864a60b0c79209d9a
Author: Jason Wang <jasowang@redhat.com>
Date:   2015-04-29 11:26:46 +0800

tun: rework on flow cache

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 1a1c4f7..19da71f 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -126,9 +126,7 @@ struct tap_filter {
 /* MAX_TAP_QUEUES 256 is chosen to allow rx/tx queues to be equal
  * to max number of VCPUs in guest. */
 #define MAX_TAP_QUEUES 256
-#define MAX_TAP_FLOWS  4096
-
-#define TUN_FLOW_EXPIRE (3 * HZ)
+#define TAP_QUEUE_MASK 0xFF
 
 /* A tun_file connects an open character device to a tuntap netdevice. It
  * also contains all socket related structures (except sock_fprog and tap_filter)
@@ -157,18 +155,13 @@ struct tun_file {
 	struct tun_struct *detached;
 };
 
-struct tun_flow_entry {
-	struct hlist_node hash_link;
-	struct rcu_head rcu;
-	struct tun_struct *tun;
-
-	u32 rxhash;
-	u32 rps_rxhash;
-	int queue_index;
-	unsigned long updated;
+struct tun_flow_table {
+	u32 ent;
+	u32 rps_hash;
 };
 
 #define TUN_NUM_FLOW_ENTRIES 1024
+#define TUN_FLOW_MASK 0x3FF
 
 /* Since the socket were moved to tun_file, to preserve the behavior of persist
  * device, socket filter, sndbuf and vnet header size were restore when the
@@ -196,13 +189,10 @@ struct tun_struct {
 	int debug;
 #endif
 	spinlock_t lock;
-	struct hlist_head flows[TUN_NUM_FLOW_ENTRIES];
-	struct timer_list flow_gc_timer;
-	unsigned long ageing_time;
+	struct tun_flow_table *flows;
 	unsigned int numdisabled;
 	struct list_head disabled;
 	void *security;
-	u32 flow_count;
 };
 
 static inline u16 tun16_to_cpu(struct tun_struct *tun, __virtio16 val)
@@ -215,164 +205,44 @@ static inline __virtio16 cpu_to_tun16(struct tun_struct *tun, u16 val)
 	return __cpu_to_virtio16(tun->flags & TUN_VNET_LE, val);
 }
 
-static inline u32 tun_hashfn(u32 rxhash)
-{
-	return rxhash & 0x3ff;
-}
-
-static struct tun_flow_entry *tun_flow_find(struct hlist_head *head, u32 rxhash)
-{
-	struct tun_flow_entry *e;
-
-	hlist_for_each_entry_rcu(e, head, hash_link) {
-		if (e->rxhash == rxhash)
-			return e;
-	}
-	return NULL;
-}
-
-static struct tun_flow_entry *tun_flow_create(struct tun_struct *tun,
-					      struct hlist_head *head,
-					      u32 rxhash, u16 queue_index)
-{
-	struct tun_flow_entry *e = kmalloc(sizeof(*e), GFP_ATOMIC);
-
-	if (e) {
-		tun_debug(KERN_INFO, tun, "create flow: hash %u index %u\n",
-			  rxhash, queue_index);
-		e->updated = jiffies;
-		e->rxhash = rxhash;
-		e->rps_rxhash = 0;
-		e->queue_index = queue_index;
-		e->tun = tun;
-		hlist_add_head_rcu(&e->hash_link, head);
-		++tun->flow_count;
-	}
-	return e;
-}
-
-static void tun_flow_delete(struct tun_struct *tun, struct tun_flow_entry *e)
-{
-	tun_debug(KERN_INFO, tun, "delete flow: hash %u index %u\n",
-		  e->rxhash, e->queue_index);
-	hlist_del_rcu(&e->hash_link);
-	kfree_rcu(e, rcu);
-	--tun->flow_count;
-}
-
-static void tun_flow_flush(struct tun_struct *tun)
-{
-	int i;
-
-	spin_lock_bh(&tun->lock);
-	for (i = 0; i < TUN_NUM_FLOW_ENTRIES; i++) {
-		struct tun_flow_entry *e;
-		struct hlist_node *n;
-
-		hlist_for_each_entry_safe(e, n, &tun->flows[i], hash_link)
-			tun_flow_delete(tun, e);
-	}
-	spin_unlock_bh(&tun->lock);
-}
-
 static void tun_flow_delete_by_queue(struct tun_struct *tun, u16 queue_index)
 {
 	int i;
 
-	spin_lock_bh(&tun->lock);
-	for (i = 0; i < TUN_NUM_FLOW_ENTRIES; i++) {
-		struct tun_flow_entry *e;
-		struct hlist_node *n;
-
-		hlist_for_each_entry_safe(e, n, &tun->flows[i], hash_link) {
-			if (e->queue_index == queue_index)
-				tun_flow_delete(tun, e);
-		}
-	}
-	spin_unlock_bh(&tun->lock);
-}
-
-static void tun_flow_cleanup(unsigned long data)
-{
-	struct tun_struct *tun = (struct tun_struct *)data;
-	unsigned long delay = tun->ageing_time;
-	unsigned long next_timer = jiffies + delay;
-	unsigned long count = 0;
-	int i;
-
-	tun_debug(KERN_INFO, tun, "tun_flow_cleanup\n");
-
-	spin_lock_bh(&tun->lock);
 	for (i = 0; i < TUN_NUM_FLOW_ENTRIES; i++) {
-		struct tun_flow_entry *e;
-		struct hlist_node *n;
-
-		hlist_for_each_entry_safe(e, n, &tun->flows[i], hash_link) {
-			unsigned long this_timer;
-			count++;
-			this_timer = e->updated + delay;
-			if (time_before_eq(this_timer, jiffies))
-				tun_flow_delete(tun, e);
-			else if (time_before(this_timer, next_timer))
-				next_timer = this_timer;
-		}
+		if ((tun->flows[i].ent & TAP_QUEUE_MASK) == queue_index)
+			tun->flows[i].ent = 0;
 	}
-
-	if (count)
-		mod_timer(&tun->flow_gc_timer, round_jiffies_up(next_timer));
-	spin_unlock_bh(&tun->lock);
 }
 
-static void tun_flow_update(struct tun_struct *tun, u32 rxhash,
-			    struct tun_file *tfile)
+static void tun_flow_update(struct tun_struct *tun,
+			    struct tun_file *tfile,
+			    u32 sw_hash)
 {
-	struct hlist_head *head;
-	struct tun_flow_entry *e;
-	unsigned long delay = tun->ageing_time;
-	u16 queue_index = tfile->queue_index;
+	int index = sw_hash & TUN_FLOW_MASK;
+	u32 val = (sw_hash & ~TAP_QUEUE_MASK) | tfile->queue_index;
 
 	if (!rxhash)
 		return;
+	else if (tun->flows[index].ent != val)
+		tun->flows[index].ent = val;
 	else
-		head = &tun->flows[tun_hashfn(rxhash)];
-
-	rcu_read_lock();
-
-	/* We may get a very small possibility of OOO during switching, not
-	 * worth to optimize.*/
-	if (tun->numqueues == 1 || tfile->detached)
-		goto unlock;
-
-	e = tun_flow_find(head, rxhash);
-	if (likely(e)) {
-		/* TODO: keep queueing to old queue until it's empty? */
-		e->queue_index = queue_index;
-		e->updated = jiffies;
-		sock_rps_record_flow_hash(e->rps_rxhash);
-	} else {
-		spin_lock_bh(&tun->lock);
-		if (!tun_flow_find(head, rxhash) &&
-		    tun->flow_count < MAX_TAP_FLOWS)
-			tun_flow_create(tun, head, rxhash, queue_index);
-
-		if (!timer_pending(&tun->flow_gc_timer))
-			mod_timer(&tun->flow_gc_timer,
-				  round_jiffies_up(jiffies + delay));
-		spin_unlock_bh(&tun->lock);
-	}
-
-unlock:
-	rcu_read_unlock();
+		sock_rps_record_flow_hash(tun->flows[index].rps_hash);
 }
 
-/**
- * Save the hash received in the stack receive path and update the
- * flow_hash table accordingly.
- */
-static inline void tun_flow_save_rps_rxhash(struct tun_flow_entry *e, u32 hash)
+static void tun_flow_rps_update(struct tun_struct *tun,
+				struct tun_file *tfile,
+				u32 sw_hash, u32 hash)
 {
-	if (unlikely(e->rps_rxhash != hash))
-		e->rps_rxhash = hash;
+	int index = sw_hash & TUN_FLOW_MASK;
+	u32 val = (sw_hash & ~TAP_QUEUE_MASK) | tfile->queue_index;
+
+	if (!hash || !sw_hash) {
+		return;
+	} else if ((tun->flows[index].ent ^ sw_hash) & ~TAP_QUEUE_MASK)
+		return;
+	else
+		tun->flows[index].rps_hash = hash;
 }
 
 /* We try to identify a flow through its rxhash first. The reason that
@@ -386,22 +256,24 @@ static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb,
 			    void *accel_priv, select_queue_fallback_t fallback)
 {
 	struct tun_struct *tun = netdev_priv(dev);
-	struct tun_flow_entry *e;
+	u32 hash, sw_hash;
 	u32 txq = 0;
 	u32 numqueues = 0;
-
 	rcu_read_lock();
 	numqueues = ACCESS_ONCE(tun->numqueues);
 
-	txq = skb_get_hash(skb);
-	if (txq) {
-		e = tun_flow_find(&tun->flows[tun_hashfn(txq)], txq);
-		if (e) {
-			tun_flow_save_rps_rxhash(e, txq);
-			txq = e->queue_index;
-		} else
+	hash = skb_get_hash(skb);
+	sw_hash = skb_get_sw_hash(skb);
+	tun_flow_rps_update(tun, tfile, sw_hash, hash);
+
+	if (sw_hash) {
+		u32 ident = tun->flows[sw_hash & TUN_FLOW_MASK].ent;
+
+		if ((ident ^ sw_hash) & ~TAP_QUEUE_MASK) {
 			/* use multiply and shift instead of expensive divide */
-			txq = ((u64)txq * numqueues) >> 32;
+			txq = ((u64)sw_hash * numqueues) >> 32;
+		} else
+			txq = ident & TAP_QUEUE_MASK;
 	} else if (likely(skb_rx_queue_recorded(skb))) {
 		txq = skb_get_rx_queue(skb);
 		while (unlikely(txq >= numqueues))
@@ -764,19 +636,12 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 		goto drop;
 
 	if (numqueues == 1) {
+		u32 hash = skb_get_hash(skb);
+		u32 sw_hash = skb_get_sw_hash(skb);
 		/* Select queue was not called for the skbuff, so we extract the
 		 * RPS hash and save it into the flow_table here.
 		 */
-		__u32 rxhash;
-
-		rxhash = skb_get_hash(skb);
-		if (rxhash) {
-			struct tun_flow_entry *e;
-			e = tun_flow_find(&tun->flows[tun_hashfn(rxhash)],
-					rxhash);
-			if (e)
-				tun_flow_save_rps_rxhash(e, rxhash);
-		}
+		tun_flow_rps_update(tun, tfile, sw_hash, hash);
 	}
 
 	tun_debug(KERN_INFO, tun, "tun_net_xmit %d\n", skb->len);
@@ -910,21 +775,13 @@ static const struct net_device_ops tap_netdev_ops = {
 
 static void tun_flow_init(struct tun_struct *tun)
 {
-	int i;
-
-	for (i = 0; i < TUN_NUM_FLOW_ENTRIES; i++)
-		INIT_HLIST_HEAD(&tun->flows[i]);
-
-	tun->ageing_time = TUN_FLOW_EXPIRE;
-	setup_timer(&tun->flow_gc_timer, tun_flow_cleanup, (unsigned long)tun);
-	mod_timer(&tun->flow_gc_timer,
-		  round_jiffies_up(jiffies + tun->ageing_time));
+	tun->flows = vzalloc(sizeof(struct tun_flow_table) *
+			     TUN_NUM_FLOW_ENTRIES);
 }
 
 static void tun_flow_uninit(struct tun_struct *tun)
 {
-	del_timer_sync(&tun->flow_gc_timer);
-	tun_flow_flush(tun);
+	vfree(tun->flows);
 }
 
 /* Initialize net device. */
@@ -1036,7 +893,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	int copylen;
 	bool zerocopy = false;
 	int err;
-	u32 rxhash;
+	u32 sw_hash;
 	ssize_t n;
 
 	if (!(tun->flags & IFF_NO_PI)) {
@@ -1201,13 +1058,13 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	skb_reset_network_header(skb);
 	skb_probe_transport_header(skb, 0);
 
-	rxhash = skb_get_hash(skb);
+	sw_hash = skb_get_sw_hash(skb);
 	netif_rx_ni(skb);
 
 	tun->dev->stats.rx_packets++;
 	tun->dev->stats.rx_bytes += len;
 
-	tun_flow_update(tun, rxhash, tfile);
+	tun_flow_update(tun, tfile, sw_hash);
 	return total_len;
 }
 
@@ -1238,6 +1095,7 @@ static ssize_t tun_put_user(struct tun_struct *tun,
 	int vlan_offset = 0;
 	int vlan_hlen = 0;
 	int vnet_hdr_sz = 0;
+	u32 sw_hash;
 
 	if (skb_vlan_tag_present(skb))
 		vlan_hlen = VLAN_HLEN;
@@ -1334,6 +1192,8 @@ static ssize_t tun_put_user(struct tun_struct *tun,
 	skb_copy_datagram_iter(skb, vlan_offset, iter, skb->len - vlan_offset);
 
 done:
+	sw_hash = skb_get_sw_hash(sbk);
+	sock_rps_record_flow_hash(tun->flows[sw_hash & TUN_FLOW_MASK].rps_hash);
 	tun->dev->stats.tx_packets++;
 	tun->dev->stats.tx_bytes += skb->len + vlan_hlen;
