Bottom: f638a155bab74aab7dbb9086c018a067849ad5c6
Top:    530957a3e558423a7e89136bfa8c4a8e8bf5d7c5
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-03-23 17:10:24 +0800

vhost: accelerate vq metadata access with vmap()

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 47b7af0..686c9ab 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -300,6 +300,60 @@ static void vhost_vq_meta_reset(struct vhost_dev *d)
 		__vhost_vq_meta_reset(d->vqs[i]);
 }
 
+static int vhost_map_uaddr(struct vhost_virtqueue *vq)
+{
+	size_t s = vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX) ? 2 : 0;
+	u64 used = (u64)vq->used;
+	u64 desc = (u64)vq->desc;
+	u64 offset;
+	struct page *pages[4];
+	size_t len;
+	int n, res;
+
+	offset = used & (PAGE_SIZE - 1);
+	len = sizeof *vq->used + vq->num * sizeof *vq->used->ring + s;
+	n = DIV_ROUND_UP(len, PAGE_SIZE);
+	printk("used %p\n", used);
+	res = get_user_pages_fast(used, n, 1, pages);
+	if (unlikely(res < n)) {
+		printk("gup fail! res %d n %d\n", res, n);
+		/* FIXME: put pages */
+		return -EFAULT;
+	}
+	printk("succeed!\n");
+	vq->used_addr = vmap(pages, n, VM_MAP, PAGE_KERNEL) + offset;
+	if (!vq->used_addr) {
+		printk("vmap fail!\n");
+		return -EFAULT;
+	}
+
+	offset = desc & (PAGE_SIZE - 1);
+	len = vq->num * sizeof *vq->desc;
+	n = DIV_ROUND_UP(len, PAGE_SIZE);
+	printk("desc %p\n", desc);
+	res = get_user_pages_fast(desc, n, 1, pages);
+	if (unlikely(res < n)) {
+		printk("gup fail! res %d n %d\n", res, n);
+		/* FIXME: put pages and vunmap */
+		return -EFAULT;
+	}
+	vq->desc_addr = vmap(pages, n, VM_MAP, PAGE_KERNEL) + offset;
+	if (!vq->desc_addr) {
+		printk("vmap fail!\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+static void vhost_unmap_uaddr(struct vhost_virtqueue *vq)
+{
+	if (vq->used_addr)
+		vunmap(vq->used_addr);
+	if (vq->desc_addr)
+		vunmap(vq->desc_addr);
+}
+
 static void vhost_vq_reset(struct vhost_dev *dev,
 			   struct vhost_virtqueue *vq)
 {
@@ -330,7 +384,10 @@ static void vhost_vq_reset(struct vhost_dev *dev,
 	vq->busyloop_timeout = 0;
 	vq->umem = NULL;
 	vq->iotlb = NULL;
+	vq->used_addr = 0;
+	vq->desc_addr = 0;
 	__vhost_vq_meta_reset(vq);
+	vhost_unmap_uaddr(vq);
 }
 
 static int vhost_worker(void *data)
@@ -1355,6 +1412,8 @@ static long vhost_set_memory(struct vhost_dev *d, struct vhost_memory __user *m)
 	return -EFAULT;
 }
 
+#define MAX_VHOST_PAGES 4
+
 long vhost_vring_ioctl(struct vhost_dev *d, int ioctl, void __user *argp)
 {
 	struct file *eventfp, *filep = NULL;
@@ -1476,6 +1535,13 @@ long vhost_vring_ioctl(struct vhost_dev *d, int ioctl, void __user *argp)
 		vq->avail = (void __user *)(unsigned long)a.avail_user_addr;
 		vq->log_addr = a.log_guest_addr;
 		vq->used = (void __user *)(unsigned long)a.used_user_addr;
+		printk("vq->used %p\n", vq->used);
+		if (vhost_map_uaddr(vq)) {
+			printk("fail to map!\n");
+		} else {
+			printk("map %p to vaddr %p\n",
+				vq->used, vq->used_addr);
+		}
 		break;
 	case VHOST_SET_VRING_KICK:
 		if (copy_from_user(&f, argp, sizeof f)) {
@@ -2007,7 +2073,7 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 		      unsigned int *out_num, unsigned int *in_num,
 		      struct vhost_log *log, unsigned int *log_num)
 {
-	struct vring_desc desc;
+	struct vring_desc *desc;
 	unsigned int i, head, found = 0;
 	u16 last_avail_idx;
 	__virtio16 avail_idx;
@@ -2081,6 +2147,7 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			       i, vq->num, head);
 			return -EINVAL;
 		}
+		#if 0
 		ret = vhost_copy_from_user(vq, &desc, vq->desc + i,
 					   sizeof desc);
 		if (unlikely(ret)) {
@@ -2088,10 +2155,12 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			       i, vq->desc + i);
 			return -EFAULT;
 		}
-		if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT)) {
+		#endif
+		desc = &vq->desc_addr[i];
+		if (desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT)) {
 			ret = get_indirect(vq, iov, iov_size,
 					   out_num, in_num,
-					   log, log_num, &desc);
+					   log, log_num, desc);
 			if (unlikely(ret < 0)) {
 				if (ret != -EAGAIN)
 					vq_err(vq, "Failure detected "
@@ -2101,12 +2170,12 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			continue;
 		}
 
-		if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+		if (desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
 			access = VHOST_ACCESS_WO;
 		else
 			access = VHOST_ACCESS_RO;
-		ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
-				     vhost32_to_cpu(vq, desc.len), iov + iov_count,
+		ret = translate_desc(vq, vhost64_to_cpu(vq, desc->addr),
+				     vhost32_to_cpu(vq, desc->len), iov + iov_count,
 				     iov_size - iov_count, access);
 		if (unlikely(ret < 0)) {
 			if (ret != -EAGAIN)
@@ -2119,8 +2188,8 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			 * increment that count. */
 			*in_num += ret;
 			if (unlikely(log)) {
-				log[*log_num].addr = vhost64_to_cpu(vq, desc.addr);
-				log[*log_num].len = vhost32_to_cpu(vq, desc.len);
+				log[*log_num].addr = vhost64_to_cpu(vq, desc->addr);
+				log[*log_num].len = vhost32_to_cpu(vq, desc->len);
 				++*log_num;
 			}
 		} else {
@@ -2133,7 +2202,7 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			}
 			*out_num += ret;
 		}
-	} while ((i = next_desc(vq, &desc)) != -1);
+	} while ((i = next_desc(vq, desc)) != -1);
 
 	/* On success, increment avail index. */
 	vq->last_avail_idx++;
@@ -2232,24 +2301,22 @@ static int __vhost_add_used_n(struct vhost_virtqueue *vq,
 			    struct vring_used_elem *heads,
 			    unsigned count)
 {
-	struct vring_used_elem __user *used;
+	struct vring_used_elem *used;
 	u16 old, new;
 	int start;
 
 	start = vq->last_used_idx & (vq->num - 1);
-	used = vq->used->ring + start;
+	used = vq->used_addr->ring + start;
 	if (count == 1) {
-		if (vhost_put_user(vq, heads[0].id, &used->id)) {
-			vq_err(vq, "Failed to write used id");
-			return -EFAULT;
-		}
-		if (vhost_put_user(vq, heads[0].len, &used->len)) {
-			vq_err(vq, "Failed to write used len");
-			return -EFAULT;
+		used->id = heads[0].id;
+		used->len = heads[0].len;
+	} else {
+		int i;
+		for (i = 0; i < count; i++) {
+			used->id = heads[i].id;
+			used->len = heads[i].len;
+			++used;
 		}
-	} else if (vhost_copy_to_user(vq, used, heads, count * sizeof *used)) {
-		vq_err(vq, "Failed to write used");
-		return -EFAULT;
 	}
 	if (unlikely(vq->log_used)) {
 		/* Make sure data is seen before log. */
diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h
index 0876116..a2c9440 100644
--- a/drivers/vhost/vhost.h
+++ b/drivers/vhost/vhost.h
@@ -93,6 +93,8 @@ struct vhost_virtqueue {
 	struct vring_desc __user *desc;
 	struct vring_avail __user *avail;
 	struct vring_used __user *used;
+	struct vring_used *used_addr;
+	struct vring_desc *desc_addr;
 	const struct vhost_umem_node *meta_iotlb[VHOST_NUM_ADDRS];
 	struct file *kick;
 	struct file *call;
