Bottom: 5750b540a14138aa263260dce70c3da7a7e21d42
Top:    3f6f59793f5bcd400670a2d2ea6c76c611aee1d1
Author: Jason Wang <jasowang@redhat.com>
Date:   2014-02-24 11:05:40 +0800

tuntap: convert to NAPI

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index e16487c..bbf4cfb 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -73,6 +73,7 @@
 #include <linux/uio.h>
 
 #include <asm/uaccess.h>
+#include <linux/interrupt.h>
 
 /* Uncomment to enable debugging */
 /* #define TUN_DEBUG 1 */
@@ -167,6 +168,8 @@ struct tun_file {
 	};
 	struct list_head next;
 	struct tun_struct *detached;
+	struct napi_struct napi;
+	struct work_struct poll_work;
 };
 
 struct tun_flow_entry {
@@ -526,6 +529,12 @@ static void __tun_detach(struct tun_file *tfile, bool clean)
 
 	tun = rtnl_dereference(tfile->tun);
 
+	if (tun) {
+		cancel_work_sync(&tfile->poll_work);
+		napi_disable(&tfile->napi);
+		netif_napi_del(&tfile->napi);
+	}
+
 	if (tun && !tfile->detached) {
 		u16 index = tfile->queue_index;
 		BUG_ON(index >= tun->numqueues);
@@ -579,6 +588,7 @@ static void tun_detach_all(struct net_device *dev)
 
 	for (i = 0; i < n; i++) {
 		tfile = rtnl_dereference(tun->tfiles[i]);
+		napi_disable(&tfile->napi);
 		BUG_ON(!tfile);
 		tfile->socket.sk->sk_shutdown = RCV_SHUTDOWN;
 		tfile->socket.sk->sk_data_ready(tfile->socket.sk);
@@ -595,6 +605,7 @@ static void tun_detach_all(struct net_device *dev)
 	synchronize_net();
 	for (i = 0; i < n; i++) {
 		tfile = rtnl_dereference(tun->tfiles[i]);
+		netif_napi_del(&tfile->napi);
 		/* Drop read queue */
 		tun_queue_purge(tfile);
 		sock_put(&tfile->sk);
@@ -610,6 +621,44 @@ static void tun_detach_all(struct net_device *dev)
 		module_put(THIS_MODULE);
 }
 
+static void poll_work(struct work_struct *work)
+{
+	struct tun_file *tfile = container_of(work, struct tun_file, poll_work);
+
+
+	local_bh_disable();
+	napi_schedule(&tfile->napi);
+	local_bh_enable();
+}
+
+static int tun_poll(struct napi_struct *napi, int budget)
+{
+	struct tun_file *tfile = container_of(napi, struct tun_file, napi);
+	struct sk_buff *skb;
+	unsigned received = 0;
+
+again:
+	while (received < budget &&
+	       (skb = skb_dequeue(&tfile->socket.sk->sk_write_queue))
+		!= NULL) {
+			netif_receive_skb(skb);
+			++received;
+	}
+
+	if (received < budget) {
+		napi_complete(napi);
+		if (skb_peek(&tfile->socket.sk->sk_write_queue) &&
+		    unlikely(napi_schedule_prep(napi))) {
+			__napi_schedule(napi);
+			goto again;
+		}
+	}
+
+	if (received > 1)
+		printk("received %d\n", received);
+	return received;
+}
+
 static int tun_attach(struct tun_struct *tun, struct file *file, bool skip_filter)
 {
 	struct tun_file *tfile = file->private_data;
@@ -653,6 +702,8 @@ static int tun_attach(struct tun_struct *tun, struct file *file, bool skip_filte
 	else
 		sock_hold(&tfile->sk);
 
+	netif_napi_add(tun->dev, &tfile->napi, tun_poll, 64);
+	napi_enable(&tfile->napi);
 	tun_set_real_num_queues(tun);
 
 	/* device is allowed to go away first, so no need to hold extra
@@ -1333,7 +1384,12 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	skb_probe_transport_header(skb, 0);
 
 	rxhash = skb_get_hash(skb);
-	netif_rx_ni(skb);
+//	netif_rx_ni(skb);
+
+	skb_queue_tail(&tfile->socket.sk->sk_write_queue, skb);
+
+	queue_work(system_unbound_wq, &tfile->poll_work);
+//	schedule_work(&tfile->poll_work);
 
 	stats = get_cpu_ptr(tun->pcpu_stats);
 	u64_stats_update_begin(&stats->syncp);
@@ -2332,6 +2388,7 @@ static int tun_chr_open(struct inode *inode, struct file * file)
 	INIT_LIST_HEAD(&tfile->next);
 
 	sock_set_flag(&tfile->sk, SOCK_ZEROCOPY);
+	INIT_WORK(&tfile->poll_work, poll_work);
 
 	return 0;
 }
