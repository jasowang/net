Bottom: 69f001f944f5ee8e89bd266c06934b7b7506cb74
Top:    33ae4488b2aa6b838b262896443091c5540b25b0
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-05-17 21:05:13 +0800

virtio-net: fix leaking page during XDP error

We should drop the refcnt for xdp page after linearizing during
errors. Otherwise xdp page will be leaked. Unfortunately, we forget to
do this for the following cases:

- when we meet gso packets
- when we fail to convert to xdp frame

This patch fixes this by moving the logic of linearization and
put_page() under err_xdp label. This will make sure all err path can
drop the refcnt correctly.



---

diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 910d2e7..48883b7 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -698,7 +698,7 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 {
 	struct virtio_net_hdr_mrg_rxbuf *hdr = buf;
 	u16 num_buf = virtio16_to_cpu(vi->vdev, hdr->num_buffers);
-	struct page *page = virt_to_head_page(buf);
+	struct page *xdp_page, *page = virt_to_head_page(buf);
 	int offset = buf - page_address(page);
 	struct sk_buff *head_skb, *curr_skb;
 	struct bpf_prog *xdp_prog;
@@ -712,7 +712,6 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 	xdp_prog = rcu_dereference(rq->xdp_prog);
 	if (xdp_prog) {
 		struct xdp_frame *xdpf;
-		struct page *xdp_page;
 		struct xdp_buff xdp;
 		void *data;
 		u32 act;
@@ -731,7 +730,7 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 						      VIRTIO_XDP_HEADROOM,
 						      &len);
 			if (!xdp_page)
-				goto err_xdp;
+				goto err_linearize;
 			offset = VIRTIO_XDP_HEADROOM;
 		} else {
 			xdp_page = page;
@@ -786,8 +785,6 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 			err = __virtnet_xdp_xmit(vi, xdpf);
 			if (unlikely(err)) {
 				trace_xdp_exception(vi->dev, xdp_prog, act);
-				if (unlikely(xdp_page != page))
-					put_page(xdp_page);
 				goto err_xdp;
 			}
 			*xdp_xmit = true;
@@ -797,11 +794,8 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 			goto xdp_xmit;
 		case XDP_REDIRECT:
 			err = xdp_do_redirect(dev, &xdp, xdp_prog);
-			if (err) {
-				if (unlikely(xdp_page != page))
-					put_page(xdp_page);
+			if (err)
 				goto err_xdp;
-			}
 			*xdp_xmit = true;
 			if (unlikely(xdp_page != page))
 				put_page(page);
@@ -812,8 +806,6 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 		case XDP_ABORTED:
 			trace_xdp_exception(vi->dev, xdp_prog, act);
 		case XDP_DROP:
-			if (unlikely(xdp_page != page))
-				__free_pages(xdp_page, 0);
 			goto err_xdp;
 		}
 	}
@@ -889,6 +881,9 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 	return head_skb;
 
 err_xdp:
+	if (unlikely(xdp_page != page))
+		put_page(xdp_page);
+err_linearize:
 	rcu_read_unlock();
 err_skb:
 	put_page(page);
