Bottom: a436a7c6e63d808104953e50bcf6f9135af7b645
Top:    b3c57295fbba2bf719e0e1a0eebba1d4e5204843
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-05-17 21:05:13 +0800

virtio-net: fix leaking page during XDP error

We should drop the refcnt for xdp page after linearizing during
errors. Otherwise xdp page will be leaked. Unfortunately, we forget to
do this for the following cases:

- gso packets
- fail to convert to xdp frame

This patch fixes this by moving the logic of xdp_page free under
err_xdp label. This will make sure all err path can drop the refcnt
correctly.

Cc: John Fastabend <john.fastabend@gmail.com>
Cc: Jesper Dangaard Brouer <brouer@redhat.com>
Fixes: 72979a6c3590 ("virtio_net: xdp, add slowpath case for non contiguous buffers")
Fixes: 44fa2dbd4759 ("xdp: transition into using xdp_frame for ndo_xdp_xmit")
Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index c57d588..eb5736e 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -727,7 +727,7 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 						      VIRTIO_XDP_HEADROOM,
 						      &len);
 			if (!xdp_page)
-				goto err_xdp;
+				goto err_linearize;
 			num_buf = 1;
 			offset = VIRTIO_XDP_HEADROOM;
 		} else {
@@ -783,8 +783,6 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 			err = __virtnet_xdp_xmit(vi, xdpf);
 			if (unlikely(err)) {
 				trace_xdp_exception(vi->dev, xdp_prog, act);
-				if (unlikely(xdp_page != page))
-					put_page(xdp_page);
 				goto err_xdp;
 			}
 			*xdp_xmit = true;
@@ -794,11 +792,8 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 			goto xdp_xmit;
 		case XDP_REDIRECT:
 			err = xdp_do_redirect(dev, &xdp, xdp_prog);
-			if (err) {
-				if (unlikely(xdp_page != page))
-					put_page(xdp_page);
+			if (err)
 				goto err_xdp;
-			}
 			*xdp_xmit = true;
 			if (unlikely(xdp_page != page))
 				put_page(page);
@@ -886,6 +881,9 @@ static struct sk_buff *receive_mergeable(struct net_device *dev,
 	return head_skb;
 
 err_xdp:
+	if (unlikely(xdp_page != page))
+		put_page(xdp_page);
+err_linearize:
 	rcu_read_unlock();
 err_skb:
 	put_page(page);
