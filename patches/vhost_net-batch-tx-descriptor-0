Bottom: ba35314f074c99aa60c55d8721eb720a67d4746e
Top:    569b2a3a37b6f8349d0e181801a29cff154c6b61
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-01-10 15:52:50 +0800

vhost_net: batch tx descriptor reading

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index c42e9c3..7736e0d 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -328,27 +328,32 @@ static int vhost_net_enable_vq(struct vhost_net *n,
 	return vhost_poll_start(poll, sock->file);
 }
 
-static int vhost_net_tx_get_vq_desc(struct vhost_net *net,
-				    struct vhost_virtqueue *vq,
-				    struct iovec iov[], unsigned int iov_size,
-				    unsigned int *out_num, unsigned int *in_num)
+static struct vhost_desc *vhost_net_tx_get_vq_desc(struct vhost_net *net,
+						   struct vhost_virtqueue *vq,
+						   unsigned int *out_num,
+						   unsigned int *in_num)
 {
+	struct vhost_desc *desc = vhost_get_vq_desc_batched(vq, NULL);
 	unsigned long uninitialized_var(endtime);
-	int r = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov),
-				  out_num, in_num, NULL, NULL);
 
-	if (r == vq->num && vq->busyloop_timeout) {
+	if (desc == NULL && vq->busyloop_timeout) {
 		preempt_disable();
 		endtime = busy_clock() + vq->busyloop_timeout;
 		while (vhost_can_busy_poll(vq->dev, endtime) &&
 		       vhost_vq_avail_empty(vq->dev, vq))
 			cpu_relax();
 		preempt_enable();
-		r = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov),
-				      out_num, in_num, NULL, NULL);
+		desc = vhost_get_vq_desc_batched(vq, NULL);
 	}
 
-	return r;
+	if (desc && desc->head >= 0 && desc->head != vq->num) {
+		*out_num = desc->out_num;
+		*in_num = desc->in_num;
+	} else {
+		*out_num = *in_num = 0;
+	}
+
+	return desc;
 }
 
 static bool vhost_exceeds_maxpend(struct vhost_net *net)
@@ -380,6 +385,8 @@ static void handle_tx(struct vhost_net *net)
 	size_t hdr_size;
 	struct socket *sock;
 	struct vhost_net_ubuf_ref *uninitialized_var(ubufs);
+	struct iovec *iov;
+	struct vhost_desc *desc;
 	bool zcopy, zcopy_used;
 
 	mutex_lock(&vq->mutex);
@@ -406,9 +413,13 @@ static void handle_tx(struct vhost_net *net)
 		if (unlikely(vhost_exceeds_maxpend(net)))
 			break;
 
-		head = vhost_net_tx_get_vq_desc(net, vq, vq->iov,
-						ARRAY_SIZE(vq->iov),
-						&out, &in);
+		desc = vhost_net_tx_get_vq_desc(net, vq, &out, &in);
+		/* TODO: for safe! */
+		if (desc == NULL) {
+			printk("NULL!\n");
+			break;
+		}
+		head = desc->head;
 		/* On error, stop handling until the next kick. */
 		if (unlikely(head < 0))
 			break;
@@ -425,9 +436,10 @@ static void handle_tx(struct vhost_net *net)
 			       "out %d, int %d\n", out, in);
 			break;
 		}
+		iov = vq->iov + desc->offset;
 		/* Skip header. TODO: support TSO. */
-		len = iov_length(vq->iov, out);
-		iov_iter_init(&msg.msg_iter, WRITE, vq->iov, out, len);
+		len = iov_length(iov, out);
+		iov_iter_init(&msg.msg_iter, WRITE, iov, out, len);
 		iov_iter_advance(&msg.msg_iter, hdr_size);
 		/* Sanity check */
 		if (!msg_data_left(&msg)) {
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 91d0500..c3b7a71 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -2059,6 +2059,7 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 	/* Assume notifications from guest are disabled at this point,
 	 * if they aren't we would need to update avail_event index. */
 	BUG_ON(!(vq->used_flags & VRING_USED_F_NO_NOTIFY));
+//	printk("vq %p head %d\n", vq, head);
 	return head;
 }
 EXPORT_SYMBOL_GPL(vhost_get_vq_desc);
@@ -2067,13 +2068,12 @@ struct vhost_desc *vhost_get_vq_desc_batched(struct vhost_virtqueue *vq,
 					     struct vhost_log *log)
 {
 	struct vhost_desc *ret;
-	int offset, r;
+	int offset;
 
 again:
 	if (vq->max_desc) {
 		ret = &vq->descs[vq->current_desc];
-
-		if (vq->current_desc == vq->max_desc)
+		if (vq->current_desc + 1 == vq->max_desc)
 			vq->current_desc = vq->max_desc = 0;
 		else
 			vq->current_desc++;
@@ -2085,13 +2085,18 @@ struct vhost_desc *vhost_get_vq_desc_batched(struct vhost_virtqueue *vq,
 	while (vq->max_desc < VHOST_MAX_TX_BATCHED) {
 		struct vhost_desc *desc = &vq->descs[vq->max_desc];
 
-		r = vhost_get_vq_desc(vq, vq->iov + offset, UIO_MAXIOV,
-				      &desc->out_num, &desc->in_num,
-				      log, &desc->log_num);
-		if (r || r == vq->num)
+		desc->head = vhost_get_vq_desc(vq, vq->iov + offset, UIO_MAXIOV,
+					       &desc->out_num, &desc->in_num,
+					       log, &desc->log_num);
+		++vq->max_desc;
+		if (desc->head >= 0 && desc->head != vq->num) {
+			desc->offset = offset;
+			offset += desc->out_num + desc->in_num;
+		} else
 			break;
 
-		++vq->max_desc;
+		if (offset > UIO_MAXIOV)
+			break;
 	}
 
 	if (vq->max_desc)
diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h
index 61ff7bd..17e658c 100644
--- a/drivers/vhost/vhost.h
+++ b/drivers/vhost/vhost.h
@@ -199,6 +199,8 @@ int vhost_get_vq_desc(struct vhost_virtqueue *,
 		      struct iovec iov[], unsigned int iov_count,
 		      unsigned int *out_num, unsigned int *in_num,
 		      struct vhost_log *log, unsigned int *log_num);
+struct vhost_desc *vhost_get_vq_desc_batched(struct vhost_virtqueue *vq,
+                                             struct vhost_log *log);
 void vhost_discard_vq_desc(struct vhost_virtqueue *, int n);
 
 int vhost_vq_init_access(struct vhost_virtqueue *);
