Bottom: 2a787f3f87eac29273fddb1134be33467041e3c2
Top:    370d2e9d02288bf5f125beaf02726dc246efc1c4
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-01-10 15:52:50 +0800

vhost_net: batch tx descriptor reading

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 5dc3465..b516445 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -328,27 +328,32 @@ static int vhost_net_enable_vq(struct vhost_net *n,
 	return vhost_poll_start(poll, sock->file);
 }
 
-static int vhost_net_tx_get_vq_desc(struct vhost_net *net,
-				    struct vhost_virtqueue *vq,
-				    struct iovec iov[], unsigned int iov_size,
-				    unsigned int *out_num, unsigned int *in_num)
+static struct vhost_desc *vhost_net_tx_get_vq_desc(struct vhost_net *net,
+						   struct vhost_virtqueue *vq,
+						   unsigned int *out_num,
+						   unsigned int *in_num)
 {
+	struct vhost_desc *desc = vhost_get_vq_desc_batched(vq, NULL);
 	unsigned long uninitialized_var(endtime);
-	int r = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov),
-				  out_num, in_num, NULL, NULL);
 
-	if (r == vq->num && vq->busyloop_timeout) {
+	if (desc == NULL && vq->busyloop_timeout) {
 		preempt_disable();
 		endtime = busy_clock() + vq->busyloop_timeout;
 		while (vhost_can_busy_poll(vq->dev, endtime) &&
 		       vhost_vq_avail_empty(vq->dev, vq))
 			cpu_relax();
 		preempt_enable();
-		r = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov),
-				      out_num, in_num, NULL, NULL);
+		desc = vhost_get_vq_desc_batched(vq, NULL);
 	}
 
-	return r;
+	if (desc && desc->head >= 0 && desc->head != vq->num) {
+		*out_num = desc->out_num;
+		*in_num = desc->in_num;
+	} else {
+		*out_num = *in_num = 0;
+	}
+
+	return desc;
 }
 
 /* Expects to be always run from workqueue - which acts as
@@ -371,6 +376,8 @@ static void handle_tx(struct vhost_net *net)
 	size_t hdr_size;
 	struct socket *sock;
 	struct vhost_net_ubuf_ref *uninitialized_var(ubufs);
+	struct iovec *iov;
+	struct vhost_desc *desc;
 	bool zcopy, zcopy_used;
 
 	mutex_lock(&vq->mutex);
@@ -398,9 +405,13 @@ static void handle_tx(struct vhost_net *net)
 			      % UIO_MAXIOV == nvq->done_idx))
 			break;
 
-		head = vhost_net_tx_get_vq_desc(net, vq, vq->iov,
-						ARRAY_SIZE(vq->iov),
-						&out, &in);
+		desc = vhost_net_tx_get_vq_desc(net, vq, &out, &in);
+		/* TODO: for safe! */
+		if (desc == NULL) {
+			printk("NULL!\n");
+			break;
+		}
+		head = desc->head;
 		/* On error, stop handling until the next kick. */
 		if (unlikely(head < 0))
 			break;
@@ -417,9 +428,10 @@ static void handle_tx(struct vhost_net *net)
 			       "out %d, int %d\n", out, in);
 			break;
 		}
+		iov = vq->iov + desc->offset;
 		/* Skip header. TODO: support TSO. */
-		len = iov_length(vq->iov, out);
-		iov_iter_init(&msg.msg_iter, WRITE, vq->iov, out, len);
+		len = iov_length(iov, out);
+		iov_iter_init(&msg.msg_iter, WRITE, iov, out, len);
 		iov_iter_advance(&msg.msg_iter, hdr_size);
 		/* Sanity check */
 		if (!msg_data_left(&msg)) {
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index d41147b..5849b37 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -2054,6 +2054,7 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 	/* Assume notifications from guest are disabled at this point,
 	 * if they aren't we would need to update avail_event index. */
 	BUG_ON(!(vq->used_flags & VRING_USED_F_NO_NOTIFY));
+//	printk("vq %p head %d\n", vq, head);
 	return head;
 }
 EXPORT_SYMBOL_GPL(vhost_get_vq_desc);
@@ -2062,13 +2063,18 @@ struct vhost_desc *vhost_get_vq_desc_batched(struct vhost_virtqueue *vq,
 					     struct vhost_log *log)
 {
 	struct vhost_desc *ret;
-	int offset, r;
+	int offset;
 
 again:
 	if (vq->max_desc) {
 		ret = &vq->descs[vq->current_desc];
-
-		if (vq->current_desc == vq->max_desc)
+#if 0
+		printk("vq %p curr %d max %d\n", vq,
+			vq->current_desc, vq->max_desc);
+		printk("head %d in %d out %d offset %d\n",
+			ret->head, ret->in_num, ret->out_num, ret->offset);
+#endif
+		if (vq->current_desc + 1 == vq->max_desc)
 			vq->current_desc = vq->max_desc = 0;
 		else
 			vq->current_desc++;
@@ -2080,13 +2086,22 @@ struct vhost_desc *vhost_get_vq_desc_batched(struct vhost_virtqueue *vq,
 	while (vq->max_desc < VHOST_MAX_TX_BATCHED) {
 		struct vhost_desc *desc = &vq->descs[vq->max_desc];
 
-		r = vhost_get_vq_desc(vq, vq->iov + offset, UIO_MAXIOV,
-				      &desc->out_num, &desc->in_num,
-				      log, &desc->log_num);
-		if (r || r == vq->num)
+		desc->head = vhost_get_vq_desc(vq, vq->iov + offset, UIO_MAXIOV,
+					       &desc->out_num, &desc->in_num,
+					       log, &desc->log_num);
+#if 0
+		printk("vq %p desc->head %d max %d\n", vq, desc->head,
+			vq->max_desc);
+#endif
+		++vq->max_desc;
+		if (desc->head >= 0 && desc->head != vq->num) {
+			desc->offset = offset;
+			offset += desc->out_num + desc->in_num;
+		} else
 			break;
 
-		++vq->max_desc;
+		if (offset > UIO_MAXIOV)
+			break;
 	}
 
 	if (vq->max_desc)
diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h
index 61ff7bd..17e658c 100644
--- a/drivers/vhost/vhost.h
+++ b/drivers/vhost/vhost.h
@@ -199,6 +199,8 @@ int vhost_get_vq_desc(struct vhost_virtqueue *,
 		      struct iovec iov[], unsigned int iov_count,
 		      unsigned int *out_num, unsigned int *in_num,
 		      struct vhost_log *log, unsigned int *log_num);
+struct vhost_desc *vhost_get_vq_desc_batched(struct vhost_virtqueue *vq,
+                                             struct vhost_log *log);
 void vhost_discard_vq_desc(struct vhost_virtqueue *, int n);
 
 int vhost_vq_init_access(struct vhost_virtqueue *);
