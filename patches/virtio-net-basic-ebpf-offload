Bottom: 80d8d6c32238302049f42b9b7d74d6e43692bd55
Top:    7bc4eb68ac99c70ab41f7187563c4c8dbb752631
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-07-05 16:11:53 +0800

virtio-net: basic eBPF offload support

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index ece9784..f603d20 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -33,6 +33,7 @@
 #include <linux/netdevice.h>
 #include <linux/pci.h>
 #include <linux/debugfs.h>
+#include <linux/bpf_verifier.h>
 #include <net/route.h>
 #include <net/xdp.h>
 #include <net/net_failover.h>
@@ -223,6 +224,19 @@ struct virtnet_info {
 	struct failover *failover;
 
 	struct dentry *ddir;
+
+	struct bpf_prog *bpf_offloaded;
+	u32 bpf_offloaded_id;
+
+	u32 prog_id_gen;
+
+	bool bpf_bind_accept;
+	u32 bpf_bind_verifier_delay;
+	struct dentry *ddir_bpf_bound_progs;
+	struct list_head bpf_bound_progs;
+
+	bool bpf_xdpdrv_accept;
+	bool bpf_xdpoffload_accept;
 };
 
 struct padded_vnet_hdr {
@@ -238,6 +252,18 @@ struct padded_vnet_hdr {
 #define DRV_NAME "virtio-net"
 struct dentry *virtnet_ddir;
 
+struct virtnet_bpf_bound_prog {
+	struct virtnet_info *vi;
+	struct bpf_prog *prog;
+	struct dentry *ddir;
+	const char *state;
+	bool is_loaded;
+	struct list_head l;
+};
+
+#define pr_vlog(env, fmt, ...)	\
+	bpf_verifier_log_write(env, "[netdevsim] " fmt, ##__VA_ARGS__)
+
 /* Converting between virtqueue no. and kernel tx/rx queue no.
  * 0:rx0 1:tx0 2:rx1 3:tx1 ... 2N:rxN 2N+1:txN 2N+2:cvq
  */
@@ -2342,9 +2368,100 @@ static u32 virtnet_xdp_query(struct net_device *dev)
 	return 0;
 }
 
+static int virtnet_debugfs_bpf_string_read(struct seq_file *file, void *data)
+{
+	const char **str = file->private;
+
+	if (*str)
+		seq_printf(file, "%s\n", *str);
+
+	return 0;
+}
+
+static int virtnet_debugfs_bpf_string_open(struct inode *inode, struct file *f)
+{
+	return single_open(f, virtnet_debugfs_bpf_string_read,
+			   inode->i_private);
+}
+
+static const struct file_operations virtnet_bpf_string_fops = {
+	.owner = THIS_MODULE,
+	.open = virtnet_debugfs_bpf_string_open,
+	.release = single_release,
+	.read = seq_read,
+	.llseek = seq_lseek
+};
+
+static int virtnet_bpf_create_prog(struct virtnet_info *vi,
+				   struct bpf_prog *prog)
+{
+	struct virtnet_bpf_bound_prog *state;
+	char name[16];
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	state->vi = vi;
+	state->prog = prog;
+	state->state = "verify";
+
+	/* Program id is not populated yet when we create the state. */
+	sprintf(name, "%u", vi->prog_id_gen++);
+	state->ddir = debugfs_create_dir(name, vi->ddir_bpf_bound_progs);
+	if (IS_ERR_OR_NULL(state->ddir)) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	debugfs_create_u32("id", 0400, state->ddir, &prog->aux->id);
+	debugfs_create_file("state", 0400, state->ddir,
+			    &state->state, &virtnet_bpf_string_fops);
+	debugfs_create_bool("loaded", 0400, state->ddir, &state->is_loaded);
+
+	list_add_tail(&state->l, &vi->bpf_bound_progs);
+
+	prog->aux->offload->dev_priv = state;
+
+	return 0;
+}
+
+static int
+virtnet_bpf_verify_insn(struct bpf_verifier_env *env, int insn_idx,
+			int prev_insn)
+{
+	struct virtnet_bpf_bound_prog *state;
+
+	state = env->prog->aux->offload->dev_priv;
+	if (state->vi->bpf_bind_verifier_delay && !insn_idx)
+		msleep(state->vi->bpf_bind_verifier_delay);
+
+	if (insn_idx == env->prog->len - 1)
+		pr_vlog(env, "Hello from virtio-net!\n");
+
+	return 0;
+}
+
+static const struct bpf_prog_offload_ops virtnet_bpf_analyzer_ops = {
+	.insn_hook = virtnet_bpf_verify_insn,
+};
+
 static int virtnet_bpf(struct net_device *dev, struct netdev_bpf *bpf)
 {
+	struct virtnet_info *vi = netdev_priv(dev);
+	int err;
+
 	switch (bpf->command) {
+	case BPF_OFFLOAD_VERIFIER_PREP:
+		if (!vi->bpf_bind_accept)
+			return -EOPNOTSUPP;
+
+		err = virtnet_bpf_create_prog(vi, bpf->verifier.prog);
+		if (err)
+			return err;
+
+		bpf->verifier.ops = &virtnet_bpf_analyzer_ops;
+		return 0;
 	case XDP_SETUP_PROG:
 		return virtnet_xdp_set(dev, bpf->prog, bpf->extack);
 	case XDP_QUERY_PROG:
@@ -2372,6 +2489,34 @@ static int virtnet_get_phys_port_name(struct net_device *dev, char *buf,
 	return 0;
 }
 
+static int virtnet_bpf_init(struct virtnet_info *vi)
+{
+	INIT_LIST_HEAD(&vi->bpf_bound_progs);
+
+	debugfs_create_u32("bpf_offloaded_id", 0400, vi->ddir,
+			   &vi->bpf_offloaded_id);
+
+	vi->bpf_bind_accept = true;
+	debugfs_create_bool("bpf_bind_accept", 0600, vi->ddir,
+			    &vi->bpf_bind_accept);
+	debugfs_create_u32("bpf_bind_verifier_delay", 0600, vi->ddir,
+			   &vi->bpf_bind_verifier_delay);
+
+	vi->ddir_bpf_bound_progs =
+		debugfs_create_dir("bpf_bound_progs", vi->ddir);
+	if (IS_ERR_OR_NULL(vi->ddir_bpf_bound_progs))
+		return -ENOMEM;
+
+	vi->bpf_xdpdrv_accept = true;
+	debugfs_create_bool("bpf_xdpdrv_accept", 0600, vi->ddir,
+			    &vi->bpf_xdpdrv_accept);
+	vi->bpf_xdpoffload_accept = true;
+	debugfs_create_bool("bpf_xdpoffload_accept", 0600, vi->ddir,
+			    &vi->bpf_xdpoffload_accept);
+
+	return 0;
+}
+
 static int virtnet_init(struct net_device *dev)
 {
 	struct virtnet_info *vi = netdev_priv(dev);
@@ -2380,7 +2525,7 @@ static int virtnet_init(struct net_device *dev)
 	if (IS_ERR_OR_NULL(vi->ddir))
 		return -ENOMEM;
 
-	return 0;
+	return virtnet_bpf_init(vi);
 }
 
 static void virtnet_uninit(struct net_device *dev)
