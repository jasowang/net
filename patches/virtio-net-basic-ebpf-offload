Bottom: 102df5b4e34ff475c1dc594ef47dfde8f2292d58
Top:    b8c6aa510656df009daa7ca8a13dba262027da73
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-07-05 16:11:53 +0800

virtio-net: basic eBPF offload support

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 56813ce..b9506d1 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -33,6 +33,7 @@
 #include <linux/netdevice.h>
 #include <linux/pci.h>
 #include <linux/debugfs.h>
+#include <linux/bpf_verifier.h>
 #include <net/route.h>
 #include <net/xdp.h>
 #include <net/net_failover.h>
@@ -223,6 +224,22 @@ struct virtnet_info {
 	struct dentry *ddir;
 
 	struct bpf_prog __rcu *xdp_prog;
+
+	u32 xdp_flags;
+	int xdp_prog_mode;
+
+	struct bpf_prog *bpf_offloaded;
+	u32 bpf_offloaded_id;
+
+	u32 prog_id_gen;
+
+	bool bpf_bind_accept;
+	u32 bpf_bind_verifier_delay;
+	struct dentry *ddir_bpf_bound_progs;
+	struct list_head bpf_bound_progs;
+
+	bool bpf_xdpdrv_accept;
+	bool bpf_xdpoffload_accept;
 };
 
 struct padded_vnet_hdr {
@@ -238,6 +255,20 @@ struct padded_vnet_hdr {
 #define DRV_NAME "virtio-net"
 struct dentry *virtnet_ddir;
 
+struct virtnet_bpf_bound_prog {
+	struct virtnet_info *vi;
+	struct bpf_prog *prog;
+	struct dentry *ddir;
+	const char *state;
+	bool is_loaded;
+	struct list_head l;
+};
+
+#define VIRTNET_EA(extack, msg)	NL_SET_ERR_MSG_MOD((extack), msg)
+
+#define pr_vlog(env, fmt, ...)						\
+	bpf_verifier_log_write(env, "[netdevsim] " fmt, ##__VA_ARGS__)
+
 /* Converting between virtqueue no. and kernel tx/rx queue no.
  * 0:rx0 1:tx0 2:rx1 3:tx1 ... 2N:rxN 2N+1:txN 2N+2:cvq
  */
@@ -2333,15 +2364,239 @@ static u32 virtnet_xdp_query(struct net_device *dev)
 	return 0;
 }
 
+static int virtnet_debugfs_bpf_string_read(struct seq_file *file, void *data)
+{
+	const char **str = file->private;
+
+	if (*str)
+		seq_printf(file, "%s\n", *str);
+
+	return 0;
+}
+
+static int virtnet_debugfs_bpf_string_open(struct inode *inode, struct file *f)
+{
+	return single_open(f, virtnet_debugfs_bpf_string_read,
+			   inode->i_private);
+}
+
+static const struct file_operations virtnet_bpf_string_fops = {
+	.owner = THIS_MODULE,
+	.open = virtnet_debugfs_bpf_string_open,
+	.release = single_release,
+	.read = seq_read,
+	.llseek = seq_lseek
+};
+
+static int virtnet_bpf_create_prog(struct virtnet_info *vi,
+				   struct bpf_prog *prog)
+{
+	struct virtnet_bpf_bound_prog *state;
+	char name[16];
+
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+
+	state->vi = vi;
+	state->prog = prog;
+	state->state = "verify";
+
+	/* Program id is not populated yet when we create the state. */
+	sprintf(name, "%u", vi->prog_id_gen++);
+	state->ddir = debugfs_create_dir(name, vi->ddir_bpf_bound_progs);
+	if (IS_ERR_OR_NULL(state->ddir)) {
+		kfree(state);
+		return -ENOMEM;
+	}
+
+	debugfs_create_u32("id", 0400, state->ddir, &prog->aux->id);
+	debugfs_create_file("state", 0400, state->ddir,
+			    &state->state, &virtnet_bpf_string_fops);
+	debugfs_create_bool("loaded", 0400, state->ddir, &state->is_loaded);
+
+	list_add_tail(&state->l, &vi->bpf_bound_progs);
+
+	prog->aux->offload->dev_priv = state;
+
+	return 0;
+}
+
+static int
+virtnet_bpf_verify_insn(struct bpf_verifier_env *env, int insn_idx,
+			int prev_insn)
+{
+	struct virtnet_bpf_bound_prog *state;
+
+	state = env->prog->aux->offload->dev_priv;
+	if (state->vi->bpf_bind_verifier_delay && !insn_idx)
+		msleep(state->vi->bpf_bind_verifier_delay);
+
+	if (insn_idx == env->prog->len - 1)
+		pr_vlog(env, "Hello from virtio-net!\n");
+
+	return 0;
+}
+
+static void virtnet_bpf_destroy_prog(struct bpf_prog *prog)
+{
+	struct virtnet_bpf_bound_prog *state;
+
+	state = prog->aux->offload->dev_priv;
+	WARN(state->is_loaded,
+	     "offload state destroyed while program still bound");
+	debugfs_remove_recursive(state->ddir);
+	list_del(&state->l);
+	kfree(state);
+}
+
+static const struct bpf_prog_offload_ops virtnet_bpf_analyzer_ops = {
+	.insn_hook = virtnet_bpf_verify_insn,
+};
+
+static int
+virtnet_setup_prog_hw_checks(struct virtnet_info *vi, struct netdev_bpf *bpf)
+{
+	struct virtnet_bpf_bound_prog *state;
+
+	if (!bpf->prog)
+		return 0;
+
+	if (!bpf->prog->aux->offload) {
+		VIRTNET_EA(bpf->extack, "xdpoffload of non-bound program");
+		return -EINVAL;
+	}
+	if (bpf->prog->aux->offload->netdev != vi->dev) {
+		VIRTNET_EA(bpf->extack, "program bound to different dev");
+		return -EINVAL;
+	}
+
+	state = bpf->prog->aux->offload->dev_priv;
+	if (WARN_ON(strcmp(state->state, "xlated"))) {
+		VIRTNET_EA(bpf->extack, "offloading program in bad state");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void virtnet_prog_set_loaded(struct bpf_prog *prog, bool loaded)
+{
+	struct virtnet_bpf_bound_prog *state;
+
+	if (!prog || !prog->aux->offload)
+		return;
+
+	state = prog->aux->offload->dev_priv;
+	state->is_loaded = loaded;
+}
+
+static int
+virtnet_bpf_offload(struct virtnet_info *vi, struct bpf_prog *prog,
+		    bool oldprog)
+{
+	virtnet_prog_set_loaded(vi->bpf_offloaded, false);
+
+	WARN(!!vi->bpf_offloaded != oldprog,
+	     "bad offload state, expected offload %sto be active",
+	     oldprog ? "" : "not ");
+	vi->bpf_offloaded = prog;
+	vi->bpf_offloaded_id = prog ? prog->aux->id : 0;
+	virtnet_prog_set_loaded(prog, true);
+
+	return 0;
+}
+
+static bool virtnet_xdp_offload_active(struct virtnet_info *vi)
+{
+	return vi->xdp_prog_mode == XDP_ATTACHED_HW;
+}
+
+static int virtnet_xdp_offload_prog(struct virtnet_info *vi,
+				    struct netdev_bpf *bpf)
+{
+	if (!virtnet_xdp_offload_active(vi) && !bpf->prog)
+		return 0;
+	if (!virtnet_xdp_offload_active(vi) && bpf->prog && vi->bpf_offloaded) {
+		VIRTNET_EA(bpf->extack, "TC program is already loaded");
+		return -EBUSY;
+	}
+
+	return virtnet_bpf_offload(vi, bpf->prog,
+				   virtnet_xdp_offload_active(vi));
+}
+
+static int virtnet_xdp_set_prog(struct virtnet_info *vi, struct netdev_bpf *bpf)
+{
+	int err;
+
+	if (vi->xdp_prog && (bpf->flags ^ vi->xdp_flags) & XDP_FLAGS_MODES) {
+		VIRTNET_EA(bpf->extack, "program loaded with different flags");
+		return -EBUSY;
+	}
+
+	if (!vi->bpf_xdpoffload_accept) {
+		VIRTNET_EA(bpf->extack, "XDP offload disabled in DebugFS");
+		return -EOPNOTSUPP;
+	}
+
+	err = virtnet_xdp_offload_prog(vi, bpf);
+	if (err)
+		return err;
+
+	if (vi->xdp_prog)
+		bpf_prog_put(vi->xdp_prog);
+
+	vi->xdp_prog = bpf->prog;
+	vi->xdp_flags = bpf->flags;
+
+	if (!bpf->prog)
+		vi->xdp_prog_mode = XDP_ATTACHED_NONE;
+	else if (bpf->command == XDP_SETUP_PROG)
+		vi->xdp_prog_mode = XDP_ATTACHED_DRV;
+	else
+		vi->xdp_prog_mode = XDP_ATTACHED_HW;
+
+	return 0;
+}
+
 static int virtnet_bpf(struct net_device *dev, struct netdev_bpf *bpf)
 {
+	struct virtnet_info *vi = netdev_priv(dev);
+	struct virtnet_bpf_bound_prog *state;
+	int err;
+
 	switch (bpf->command) {
+	case BPF_OFFLOAD_VERIFIER_PREP:
+		if (!vi->bpf_bind_accept)
+			return -EOPNOTSUPP;
+
+		err = virtnet_bpf_create_prog(vi, bpf->verifier.prog);
+		if (err)
+			return err;
+
+		bpf->verifier.ops = &virtnet_bpf_analyzer_ops;
+		return 0;
+	case BPF_OFFLOAD_TRANSLATE:
+		state = bpf->offload.prog->aux->offload->dev_priv;
+
+		state->state = "xlated";
+		return 0;
+	case BPF_OFFLOAD_DESTROY:
+		virtnet_bpf_destroy_prog(bpf->offload.prog);
+		return 0;
 	case XDP_SETUP_PROG:
 		return virtnet_xdp_set(dev, bpf->prog, bpf->extack);
 	case XDP_QUERY_PROG:
+		bpf->prog_attached = vi->xdp_prog_mode;
 		bpf->prog_id = virtnet_xdp_query(dev);
-		bpf->prog_attached = !!bpf->prog_id;
+		bpf->prog_flags = vi->xdp_prog ? vi->xdp_flags : 0;
 		return 0;
+	case XDP_SETUP_PROG_HW:
+		err = virtnet_setup_prog_hw_checks(vi, bpf);
+		if (err)
+			return err;
+
+		return virtnet_xdp_set_prog(vi, bpf);
 	default:
 		return -EINVAL;
 	}
@@ -2363,6 +2618,34 @@ static int virtnet_get_phys_port_name(struct net_device *dev, char *buf,
 	return 0;
 }
 
+static int virtnet_bpf_init(struct virtnet_info *vi)
+{
+	INIT_LIST_HEAD(&vi->bpf_bound_progs);
+
+	debugfs_create_u32("bpf_offloaded_id", 0400, vi->ddir,
+			   &vi->bpf_offloaded_id);
+
+	vi->bpf_bind_accept = true;
+	debugfs_create_bool("bpf_bind_accept", 0600, vi->ddir,
+			    &vi->bpf_bind_accept);
+	debugfs_create_u32("bpf_bind_verifier_delay", 0600, vi->ddir,
+			   &vi->bpf_bind_verifier_delay);
+
+	vi->ddir_bpf_bound_progs =
+		debugfs_create_dir("bpf_bound_progs", vi->ddir);
+	if (IS_ERR_OR_NULL(vi->ddir_bpf_bound_progs))
+		return -ENOMEM;
+
+	vi->bpf_xdpdrv_accept = true;
+	debugfs_create_bool("bpf_xdpdrv_accept", 0600, vi->ddir,
+			    &vi->bpf_xdpdrv_accept);
+	vi->bpf_xdpoffload_accept = true;
+	debugfs_create_bool("bpf_xdpoffload_accept", 0600, vi->ddir,
+			    &vi->bpf_xdpoffload_accept);
+
+	return 0;
+}
+
 static int virtnet_init(struct net_device *dev)
 {
 	struct virtnet_info *vi = netdev_priv(dev);
@@ -2371,7 +2654,7 @@ static int virtnet_init(struct net_device *dev)
 	if (IS_ERR_OR_NULL(vi->ddir))
 		return -ENOMEM;
 
-	return 0;
+	return virtnet_bpf_init(vi);
 }
 
 static void virtnet_uninit(struct net_device *dev)
