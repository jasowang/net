Bottom: 80be38578cf732a8bb7a233550deccf5018838d9
Top:    e892700d0a1fbe9cf76c1c44ae4aeeb3dae58b53
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-12-28 22:06:20 +0800

bpf-debug


---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index fdd90f5..20e374a 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -992,11 +992,29 @@ static unsigned int run_ebpf_filter(struct tun_struct *tun,
 				    int len)
 {
 	struct tun_prog *prog = rcu_dereference(tun->filter_prog);
+	struct vlan_ethhdr *vh = (struct vlan_ethhdr *) skb->data;
+	unsigned char *bytes = (unsigned char *) skb->data;
+	unsigned int ret = len;
+	int i;
+	u32 *ptr = (u32 *) skb->data;
 
-	if (prog)
-		len = bpf_prog_run_clear_cb(prog->prog, skb);
+	if (prog) {
+		printk("vlan proto %x\n", vh->h_vlan_proto);
+		printk("sizeof(*vh) is %d\n", sizeof(*vh));
+		printk("---- dump ----\n");
+		for (i = 0; i < sizeof(*vh); i++) {
+			printk("%02x ", bytes[i]);
+		}
+		printk("--------------\n");
+		ret = bpf_prog_run_clear_cb(prog->prog, skb);
+		printk("len is %x\n", ret);
+		if (ptr[0] == 0xffffffff)
+			printk("skb->data[0] is 0xffffffff\n");
+		else
+			printk("skb->data[0] is not 0xffffffff\n");
+	}
 
-	return len;
+	return ret;
 }
 
 /* Net device start xmit */
@@ -1932,6 +1950,8 @@ static ssize_t tun_put_user(struct tun_struct *tun,
 			__be16 h_vlan_TCI;
 		} veth;
 
+		printk("vlan accelerated!\n");
+
 		veth.h_vlan_proto = skb->vlan_proto;
 		veth.h_vlan_TCI = htons(skb_vlan_tag_get(skb));
 
diff --git a/kernel/bpf/arraymap.c b/kernel/bpf/arraymap.c
index 7c25426..d1a7722 100644
--- a/kernel/bpf/arraymap.c
+++ b/kernel/bpf/arraymap.c
@@ -118,6 +118,8 @@ static void *array_map_lookup_elem(struct bpf_map *map, void *key)
 	struct bpf_array *array = container_of(map, struct bpf_array, map);
 	u32 index = *(u32 *)key;
 
+	printk("index is %d\n", index);
+
 	if (unlikely(index >= array->map.max_entries))
 		return NULL;
 
diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c
index 007802c..6e659e6 100644
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@ -99,12 +99,16 @@ static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)
 	struct bpf_map *map;
 
 	if (attr->map_type >= ARRAY_SIZE(bpf_map_types) ||
-	    !bpf_map_types[attr->map_type])
+		!bpf_map_types[attr->map_type]) {
+		printk("map type error !\n");
 		return ERR_PTR(-EINVAL);
+	}
 
 	map = bpf_map_types[attr->map_type]->map_alloc(attr);
-	if (IS_ERR(map))
+	if (IS_ERR(map)) {
+		printk("alloc error\n");
 		return map;
+	}
 	map->ops = bpf_map_types[attr->map_type];
 	map->map_type = attr->map_type;
 	return map;
@@ -388,8 +392,10 @@ static int map_create(union bpf_attr *attr)
 	int err;
 
 	err = CHECK_ATTR(BPF_MAP_CREATE);
-	if (err)
+	if (err) {
+		printk("CHECK ATTR!\n");
 		return -EINVAL;
+	}
 
 	f_flags = bpf_get_file_flag(attr->map_flags);
 	if (f_flags < 0)
@@ -397,32 +403,44 @@ static int map_create(union bpf_attr *attr)
 
 	if (numa_node != NUMA_NO_NODE &&
 	    ((unsigned int)numa_node >= nr_node_ids ||
-	     !node_online(numa_node)))
+		    !node_online(numa_node))) {
+		printk("NUMA NODE!\n");
 		return -EINVAL;
+	}
 
 	/* find map type and init map: hashtable vs rbtree vs bloom vs ... */
 	map = find_and_alloc_map(attr);
-	if (IS_ERR(map))
+	if (IS_ERR(map)) {
+		printk("Find error!\n");
 		return PTR_ERR(map);
+	}
 
 	err = bpf_obj_name_cpy(map->name, attr->map_name);
-	if (err)
+	if (err) {
+		printk("name cpy error!\n");
 		goto free_map_nouncharge;
+	}
 
 	atomic_set(&map->refcnt, 1);
 	atomic_set(&map->usercnt, 1);
 
 	err = security_bpf_map_alloc(map);
-	if (err)
+	if (err) {
+		printk("alloc error!\n");
 		goto free_map_nouncharge;
+	}
 
 	err = bpf_map_charge_memlock(map);
-	if (err)
+	if (err) {
+		printk("memlock error!\n");
 		goto free_map_sec;
+	}
 
 	err = bpf_map_alloc_id(map);
-	if (err)
+	if (err) {
+		printk("id error!\n");
 		goto free_map;
+	}
 
 	err = bpf_map_new_fd(map, f_flags);
 	if (err < 0) {
@@ -432,6 +450,7 @@ static int map_create(union bpf_attr *attr)
 		 * to the userspace and the userspace may
 		 * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.
 		 */
+		printk("new fd error!\n");
 		bpf_map_put(map);
 		return err;
 	}
@@ -453,8 +472,10 @@ static int map_create(union bpf_attr *attr)
  */
 struct bpf_map *__bpf_map_get(struct fd f)
 {
-	if (!f.file)
+	if (!f.file) {
+		printk("no file!\n");
 		return ERR_PTR(-EBADF);
+	}
 	if (f.file->f_op != &bpf_map_fops) {
 		fdput(f);
 		return ERR_PTR(-EINVAL);
@@ -618,13 +639,17 @@ static int map_update_elem(union bpf_attr *attr)
 	struct fd f;
 	int err;
 
-	if (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))
+	if (CHECK_ATTR(BPF_MAP_UPDATE_ELEM)) {
+		printk("ATTR2\n");
 		return -EINVAL;
+	}
 
 	f = fdget(ufd);
 	map = __bpf_map_get(f);
-	if (IS_ERR(map))
+	if (IS_ERR(map)) {
+		printk("map get error!\n");
 		return PTR_ERR(map);
+	}
 
 	if (!(f.file->f_mode & FMODE_CAN_WRITE)) {
 		err = -EPERM;
@@ -1771,31 +1796,44 @@ SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, siz
 	union bpf_attr attr = {};
 	int err;
 
-	if (!capable(CAP_SYS_ADMIN) && sysctl_unprivileged_bpf_disabled)
+	printk("Enter bpf!\n");
+
+	if (!capable(CAP_SYS_ADMIN) &&
+		sysctl_unprivileged_bpf_disabled) {
+		printk("-EPERM!\n");
 		return -EPERM;
+	}
 
 	err = check_uarg_tail_zero(uattr, sizeof(attr), size);
-	if (err)
+	if (err) {
+		printk("tail zero!\n");
 		return err;
+	}
 	size = min_t(u32, size, sizeof(attr));
 
 	/* copy attributes from user space, may be less than sizeof(bpf_attr) */
-	if (copy_from_user(&attr, uattr, size) != 0)
+	if (copy_from_user(&attr, uattr, size) != 0) {
+		printk("-EFAULT!\n");
 		return -EFAULT;
+	}
 
 	err = security_bpf(cmd, &attr, size);
-	if (err < 0)
+	if (err < 0) {
+		printk("security!\n");
 		return err;
+	}
 
 	switch (cmd) {
 	case BPF_MAP_CREATE:
 		err = map_create(&attr);
+		printk("create return %d\n", err);
 		break;
 	case BPF_MAP_LOOKUP_ELEM:
 		err = map_lookup_elem(&attr);
 		break;
 	case BPF_MAP_UPDATE_ELEM:
 		err = map_update_elem(&attr);
+		printk("update elem return %d\n", err);
 		break;
 	case BPF_MAP_DELETE_ELEM:
 		err = map_delete_elem(&attr);
diff --git a/samples/bpf/libbpf.h b/samples/bpf/libbpf.h
index 18bfee5..25ecccd 100644
--- a/samples/bpf/libbpf.h
+++ b/samples/bpf/libbpf.h
@@ -116,6 +116,14 @@ struct bpf_insn;
 		.off   = 0,					\
 		.imm   = IMM })
 
+#define BPF_LDX_ABS(SIZE, IMM)					\
+	((struct bpf_insn) {					\
+		.code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_ABS,	\
+		.dst_reg = 0,					\
+		.src_reg = 0,					\
+		.off   = 0,					\
+		.imm   = IMM })
+
 /* Memory load, dst_reg = *(uint *) (src_reg + off16) */
 
 #define BPF_LDX_MEM(SIZE, DST, SRC, OFF)			\
diff --git a/samples/bpf/sock_example.c b/samples/bpf/sock_example.c
index 6fc6e19..96a0bf1 100644
--- a/samples/bpf/sock_example.c
+++ b/samples/bpf/sock_example.c
@@ -45,11 +45,11 @@ static int test_sock(void)
 
 	struct bpf_insn prog[] = {
 		BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),
+		BPF_LD_MAP_FD(BPF_REG_1, map_fd),
 		BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol) /* R0 = ip->proto */),
 		BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4), /* *(u32 *)(fp - 4) = r0 */
 		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),
 		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4), /* r2 = fp - 4 */
-		BPF_LD_MAP_FD(BPF_REG_1, map_fd),
 		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),
 		BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),
 		BPF_MOV64_IMM(BPF_REG_1, 1), /* r1 = 1 */
