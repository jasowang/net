Bottom: 407f5d885c4d8941ed1e3a1c8b03061d7e8d7ac9
Top:    0659e0337a3657e227be50637f2db5f9b74aff0a
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-05-17 10:35:02 +0800

Refresh of tuntap-introduce-tx-skb-ring

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index be1f586..2ad88e2 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -927,7 +927,7 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 	if (tun->flags & IFF_TX_RING) {
 		unsigned long head, tail;
 
-		spin_lock_irqsave(&tfile->wlock, flags);
+		spin_lock(&tfile->wlock);
 
 		head = tfile->head;
 		tail = smp_load_acquire(tfile->tail);
@@ -940,15 +940,15 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 			if (skb_vlan_tag_present(skb))
 				desc->len += VLAN_HLEN;
 
-			/* read descriptor before incrementing head. */
+			/* read descriptor before incrementing tail. */
 			smp_store_release(&tfile->head,
 					  (head + 1) & TUN_RING_MASK);
 		} else {
-			spin_unlock_irqrestore(&tfile->wlock, flags);
+			spin_unlock(&tfile->wlock);
 			goto drop;
 		}
 
-		spin_unlock_irqrestore(&tfile->wlock, flags);
+		spin_unlock(&tfile->wlock)
 	} else {
 		/* Enqueue packet */
 		skb_queue_tail(&tfile->socket.sk->sk_receive_queue, skb);
@@ -1569,12 +1569,11 @@ static ssize_t tun_do_read(struct tun_struct *tun, struct tun_file *tfile,
 		struct tun_desc *desc;
 
 		spin_lock(&tfile->rlock);
+		/* Read index before reading contents at that index. */
 		head = smp_load_acquire(tfile->head);
 		tail = tfile->tail;
 
 		if (CIRC_CNT(head, tail, TUN_RING_SIZE) >= 1) {
-			/* read tail before reading descriptor at tail */
-			smp_rmb();
 			desc = &tfile->tx_descs[tail];
 			skb = desc->skb;
 			/* read descriptor before incrementing tail. */
@@ -1746,16 +1745,15 @@ static int tun_peek(struct socket *sock, bool exact)
 			ret = tfile->tx_descs[tail].len;
 	} else {
 		struct sk_buff *head;
-		unsigned long flags;
 
-		spin_lock_irqsave(&sk->sk_receive_queue.lock, flags);
+		spin_lock_bh(&sk->sk_receive_queue.lock);
 		head = skb_peek(&sk->sk_receive_queue);
 		if (likely(head)) {
 			ret = head->len;
 			if (skb_vlan_tag_present(head))
 				ret += VLAN_HLEN;
 		}
-		spin_unlock_irqrestore(&sk->sk_receive_queue.lock, flags);
+		spin_unlock_bh(&sk->sk_receive_queue.lock);
 	}
 
 	tun_put(tun);
