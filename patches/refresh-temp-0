Bottom: 0cc622fc3dd9da9be0791e0ee9176a0468625dfd
Top:    4de18263aa5dae2b8c25fbe7f164cf0cd157e689
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-05-12 15:35:46 +0800

Refresh of tuntap-introduce-tx-skb-ring

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index a76c43f..6001ece 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1148,6 +1148,13 @@ static void tun_net_init(struct net_device *dev)
 	}
 }
 
+static bool tun_queue_not_empty(struct tun_file *tfile)
+{
+	struct sock *sk = tfile->socket.sk;
+
+	return (!skb_queue_empty(&sk->sk_receive_queue) ||
+		ACCESS_ONCE(tfile->head) != ACCESS_ONCE(tfile->tail));
+}
 /* Character device part */
 
 /* Poll */
@@ -1167,8 +1174,7 @@ static unsigned int tun_chr_poll(struct file *file, poll_table *wait)
 
 	poll_wait(file, sk_sleep(sk), wait);
 
-	if (!skb_queue_empty(&sk->sk_receive_queue) ||
-	    tfile->head != tfile->tail)
+	if (tun_queue_not_empty(tfile))
 		mask |= POLLIN | POLLRDNORM;
 
 	if (sock_writeable(sk) ||
@@ -1718,12 +1724,17 @@ out:
 	return ret;
 }
 
-static int tun_peek_len(struct socket *sock)
+static int tun_peek(struct socket *sock, bool exact)
 {
 	struct tun_file *tfile = container_of(sock, struct tun_file, socket);
-	struct tun_struct *tun = __tun_get(tfile);
+	struct sock *sk = sock->sk;
+	struct tun_struct *tun;
 	int ret = 0;
 
+	if (!exact)
+		return tun_queue_not_empty(tfile);
+
+	tun = __tun_get(tfile);
 	if (!tun)
 		return 0;
 
@@ -1734,7 +1745,6 @@ static int tun_peek_len(struct socket *sock)
 		if (head != tail)
 			ret = tfile->tx_descs[tail].len;
 	} else {
-		struct sock *sk = sock->sk;
 		struct sk_buff *head;
 		unsigned long flags;
 
@@ -1754,7 +1764,7 @@ static int tun_peek_len(struct socket *sock)
 
 /* Ops structure to mimic raw sockets with tun */
 static const struct proto_ops tun_socket_ops = {
-	.peek_len = tun_peek_len,
+	.peek    = tun_peek,
 	.sendmsg = tun_sendmsg,
 	.recvmsg = tun_recvmsg,
 };
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 236ba52..10ff494 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -460,8 +460,8 @@ static int peek_head_len(struct sock *sk)
 	int len = 0;
 	unsigned long flags;
 
-	if (sock->ops->peek_len)
-		return sock->ops->peek_len(sock);
+	if (sock->ops->peek)
+		return sock->ops->peek(sock, true);
 
 	spin_lock_irqsave(&sk->sk_receive_queue.lock, flags);
 	head = skb_peek(&sk->sk_receive_queue);
@@ -479,8 +479,8 @@ static int sk_has_rx_data(struct sock *sk)
 {
 	struct socket *sock = sk->sk_socket;
 
-	if (sock->ops->peek_len)
-		return sock->ops->peek_len(sock);
+	if (sock->ops->peek)
+		return sock->ops->peek(sock, false);
 
 	return skb_queue_empty(&sk->sk_receive_queue);
 }
diff --git a/include/linux/net.h b/include/linux/net.h
index 55bf25a..3c4ecd5 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -132,7 +132,7 @@ struct module;
 struct proto_ops {
 	int		family;
 	struct module	*owner;
-	int		(*peek_len) (struct socket *sock);
+	int		(*peek) (struct socket *sock, bool exact);
 	int		(*release)   (struct socket *sock);
 	int		(*bind)	     (struct socket *sock,
 				      struct sockaddr *myaddr,
