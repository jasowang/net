Bottom: d345ffc9c640135ca0de6638a27aeb8fcdaf72f9
Top:    ed41cf7c760f1b5447e30c321446e60e48ea466b
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-07-05 10:49:02 +0800

Refresh of ip-debug

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index d97d695..4c31c1c 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1589,13 +1589,8 @@ static void tun_rx_batched(struct tun_struct *tun, struct tun_file *tfile,
 	spin_unlock(&queue->lock);
 
 	if (rcv) {
-		struct sk_buff *nskb, *tmp;
-
 		local_bh_disable();
-		list_for_each_entry_safe(nskb, tmp, &list, list) {
-			list_del_init(&nskb->list);
-			kfree_skb(nskb);
-		}
+		netif_receive_skb_list(&list);
 		local_bh_enable();
 	}
 }
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 24b9b02..e174e46 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -323,13 +323,28 @@ static int ip_rcv_finish_core(struct net *net, struct sock *sk,
 	if (!skb)
 		return NET_RX_SUCCESS;
 
-	if (net->ipv4.sysctl_ip_early_demux &&
-	    !skb_dst(skb) &&
-	    !skb->sk &&
-	    !ip_is_fragment(iph)) {
+	printk("11 skb %p iph %p net %p\n", skb, iph, net);
+	if (!net) {
+		if (skb->dev)
+			printk("devname is %s\n", skb->dev->name);
+		dump_stack();
+		goto drop_error;
+	}
+	if (net->ipv4.sysctl_ip_early_demux) {
 		const struct net_protocol *ipprot;
 		int protocol = iph->protocol;
 
+		printk("111\n");
+		if (skb_dst(skb))
+			goto pass;
+		printk("112\n");
+		if (skb->sk)
+			goto pass;
+		printk("113\n");
+		if (ip_is_fragment(iph))
+			goto pass;
+
+		printk("114\n");
 		ipprot = rcu_dereference(inet_protos[protocol]);
 		if (ipprot && (edemux = READ_ONCE(ipprot->early_demux))) {
 			err = edemux(skb);
@@ -339,7 +354,9 @@ static int ip_rcv_finish_core(struct net *net, struct sock *sk,
 			iph = ip_hdr(skb);
 		}
 	}
+pass:
 
+	printk("12\n");
 	/*
 	 *	Initialise the virtual path cache for the packet. It describes
 	 *	how the packet travels inside Linux networking.
@@ -362,9 +379,11 @@ static int ip_rcv_finish_core(struct net *net, struct sock *sk,
 	}
 #endif
 
+	printk("13\n");
 	if (iph->ihl > 5 && ip_rcv_options(skb))
 		goto drop;
 
+	printk("14\n");
 	rt = skb_rtable(skb);
 	if (rt->rt_type == RTN_MULTICAST) {
 		__IP_UPD_PO_STATS(net, IPSTATS_MIB_INMCAST, skb->len);
@@ -393,6 +412,7 @@ static int ip_rcv_finish_core(struct net *net, struct sock *sk,
 		    IN_DEV_ORCONF(in_dev, DROP_UNICAST_IN_L2_MULTICAST))
 			goto drop;
 	}
+	printk("15\n");
 
 	return NET_RX_SUCCESS;
 
@@ -543,21 +563,30 @@ static void ip_list_rcv_finish(struct net *net, struct sock *sk,
 	list_for_each_entry_safe(skb, next, head, list) {
 		struct dst_entry *dst;
 
+		printk("1 sk %p\n", sk);
 		if (ip_rcv_finish_core(net, sk, skb) == NET_RX_DROP)
 			continue;
 
+		printk("2\n");
 		dst = skb_dst(skb);
 		if (curr_dst != dst) {
 			/* dispatch old sublist */
+			printk("3 %p\n", &skb->list);
 			list_cut_before(&sublist, head, &skb->list);
-			if (!list_empty(&sublist))
+			printk("4\n");
+			if (!list_empty(&sublist)) {
+				printk("5\n");
 				ip_sublist_rcv_finish(&sublist);
+			}
+			printk("6\n");
 			/* start new sublist */
 			curr_dst = dst;
 		}
 	}
+	printk("7\n");
 	/* dispatch final sublist */
 	ip_sublist_rcv_finish(head);
+	printk("8\n");
 }
 
 static void ip_sublist_rcv(struct list_head *head, struct net_device *dev,
@@ -577,24 +606,35 @@ void ip_list_rcv(struct list_head *head, struct packet_type *pt,
 	struct sk_buff *skb, *next;
 	struct list_head sublist;
 
+	printk("start!\n");
 	list_for_each_entry_safe(skb, next, head, list) {
 		struct net_device *dev = skb->dev;
 		struct net *net = dev_net(dev);
 
+		printk("ip_list_rcv, net %p dev %s\n",
+			net, dev->name);
+
+		list_del(&skb->list);
 		skb = ip_rcv_core(skb, net);
 		if (skb == NULL)
 			continue;
 
 		if (curr_dev != dev || curr_net != net) {
 			/* dispatch old sublist */
-			list_cut_before(&sublist, head, &skb->list);
-			if (!list_empty(&sublist))
+			if (!list_empty(&sublist)) {
 				ip_sublist_rcv(&sublist, dev, net);
+				INIT_LIST_HEAD(&sublist);
+			}
 			/* start new sublist */
 			curr_dev = dev;
 			curr_net = net;
 		}
+
+		list_add_tail(&sublist, &skb->list);
 	}
+	printk("dispatch final curr_dev %p curr_net %p empty %d\n",
+		curr_dev, curr_net, list_empty(head));
 	/* dispatch final sublist */
 	ip_sublist_rcv(head, curr_dev, curr_net);
+	printk("end\n");
 }
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 24e116d..a587500 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -2317,6 +2317,7 @@ int udp_v4_early_demux(struct sk_buff *skb)
 	int sdif = inet_sdif(skb);
 	int ours;
 
+	printk("21\n");
 	/* validate the packet */
 	if (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct udphdr)))
 		return 0;
@@ -2324,6 +2325,7 @@ int udp_v4_early_demux(struct sk_buff *skb)
 	iph = ip_hdr(skb);
 	uh = udp_hdr(skb);
 
+	printk("22\n");
 	if (skb->pkt_type == PACKET_MULTICAST) {
 		in_dev = __in_dev_get_rcu(skb->dev);
 
@@ -2343,6 +2345,7 @@ int udp_v4_early_demux(struct sk_buff *skb)
 					     uh->source, iph->saddr, dif, sdif);
 	}
 
+	printk("23\n");
 	if (!sk || !refcount_inc_not_zero(&sk->sk_refcnt))
 		return 0;
 
@@ -2350,6 +2353,7 @@ int udp_v4_early_demux(struct sk_buff *skb)
 	skb->destructor = sock_efree;
 	dst = READ_ONCE(sk->sk_rx_dst);
 
+	printk("24\n");
 	if (dst)
 		dst = dst_check(dst, 0);
 	if (dst) {
@@ -2369,6 +2373,7 @@ int udp_v4_early_demux(struct sk_buff *skb)
 						     iph->saddr, iph->tos,
 						     skb->dev, in_dev, &itag);
 	}
+	printk("25\n");
 	return 0;
 }
