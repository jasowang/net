Bottom: 4927bc82d8217ee626122c99e2c7d19a7029778a
Top:    fb1a891b51935490e029affcc18680f2437c62d9
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-05-09 19:59:47 +0800

Refresh of circular-buffer

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index 3a54a44..d4d98cc 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -909,18 +909,34 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	nf_reset(skb);
 
-	/* Enqueue packet */
-	//skb_queue_tail(&tfile->socket.sk->sk_receive_queue, skb);
+	if (tun->flags & IFF_TX_RING) {
+		unsigned long head, tail;
 
-	if (((tfile->tail + 1) & TUN_RING_MASK) == tfile->head)
-		goto drop;
+		spin_lock_irqsave(&tfile->wlock, flags);
 
-	spin_lock_irqsave(&tfile->wlock, flags);
-	tfile->tx_descs[tfile->tail].skb = skb;
-	tfile->tx_descs[tfile->tail].len = skb->len;
-	smp_wmb();
-	tfile->tail = (tfile->tail + 1) & TUN_RING_MASK;
-	spin_unlock_irqrestore(&tfile->wlock, flags);
+		head = tfile->head;
+		/* The spin_unlock() and next spin_lock() provide
+		 * needed ordering. */
+		tail = ACCESS_ONCE(tfile->tail);
+
+		if (CIRC_SPACE(head, tail, TUN_RING_SIZE) >= 1) {
+			struct tun_desc *desc = &tfile->tx_descs[head];
+
+			desc->skb = skb;
+			desc->len = skb->len;
+
+			smp_store_release(&tfile->head,
+					  (head + 1) & TUN_RING_MASK);
+		} else {
+			spin_unlock_irqrestore(&tfile->wlock, flags);
+			goto drop;
+		}
+
+		spin_unlock_irqrestore(&tfile->wlock, flags);
+	} else {
+		/* Enqueue packet */
+		skb_queue_tail(&tfile->socket.sk->sk_receive_queue, skb);
+	}
 
 	/* Notify and wake up reader process */
 	if (tfile->flags & TUN_FASYNC)
