Bottom: 3c51c4d4cf7e766f737afc6a275d64bb41b12314
Top:    1a0b76da8b0ee860169899cf9053a50d0ec8b79d
Author: Jason Wang <jasowang@redhat.com>
Date:   2018-01-22 17:14:43 +0800

Refresh of tuntap-xdp_tx-can-use-native

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index a95087b..e0a7456 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -1063,6 +1063,14 @@ static unsigned int run_ebpf_filter(struct tun_struct *tun,
 	return len;
 }
 
+static void tun_flush_notify(struct tun_file *tfile)
+{
+	/* Notify and wake up reader process */
+	if (tfile->flags & TUN_FASYNC)
+		kill_fasync(&tfile->fasync, SIGIO, POLL_IN);
+	tfile->socket.sk->sk_data_ready(tfile->socket.sk);
+}
+
 /* Net device start xmit */
 static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 {
@@ -1119,10 +1127,7 @@ static netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)
 	if (ptr_ring_produce(&tfile->tx_ring, skb))
 		goto drop;
 
-	/* Notify and wake up reader process */
-	if (tfile->flags & TUN_FASYNC)
-		kill_fasync(&tfile->fasync, SIGIO, POLL_IN);
-	tfile->socket.sk->sk_data_ready(tfile->socket.sk);
+	tun_flush_notify(tfile);
 
 	rcu_read_unlock();
 	return NETDEV_TX_OK;
@@ -1341,11 +1346,7 @@ static void tun_xdp_flush(struct net_device *dev)
 
 	tfile = rcu_dereference(tun->tfiles[smp_processor_id() %
 					    numqueues]);
-	/* Notify and wake up reader process */
-	if (tfile->flags & TUN_FASYNC)
-		kill_fasync(&tfile->fasync, SIGIO, POLL_IN);
-	tfile->socket.sk->sk_data_ready(tfile->socket.sk);
-
+	tun_flush_notify(tfile);
 out:
 	rcu_read_unlock();
 }
@@ -1619,7 +1620,6 @@ static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 	unsigned int delta = 0;
 	char *buf;
 	size_t copied;
-	bool xdp_xmit = false;
 	int err, pad = TUN_RX_PAD;
 
 	rcu_read_lock();
@@ -1675,8 +1675,12 @@ static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 			tfile->xdp_flush_needed = true;
 			return NULL;
 		case XDP_TX:
-			xdp_xmit = true;
-			/* fall through */
+			err = tun_xdp_xmit(dev, xdp);
+			if (err)
+				goto err_redirect;
+			rcu_read_unock();
+			tfile->xdp_flush_needed = true;
+			return NULL;
 		case XDP_PASS:
 			delta = orig_data - xdp.data;
 			break;
@@ -1702,13 +1706,6 @@ static struct sk_buff *tun_build_skb(struct tun_struct *tun,
 	get_page(alloc_frag->page);
 	alloc_frag->offset += buflen;
 
-	if (xdp_xmit) {
-		skb->dev = tun->dev;
-		generic_xdp_tx(skb, xdp_prog);
-		rcu_read_unlock();
-		return NULL;
-	}
-
 	rcu_read_unlock();
 
 	return skb;
@@ -1992,6 +1989,8 @@ static ssize_t tun_chr_write_iter(struct kiocb *iocb, struct iov_iter *from)
 
 	if (tfile->xdp_flush_needed) {
 		tfile->xdp_flush_needed = false;
+
+		tun_flush_notify(tfile);
 		xdp_do_flush_map();
 	}
 
@@ -2334,6 +2333,7 @@ static int tun_sendmsg(struct socket *sock, struct msghdr *m, size_t total_len)
 
 	if (tfile->xdp_flush_needed && !(m->msg_flags & MSG_MORE)) {
 		tfile->xdp_flush_needed = false;
+		tun_flush_notify(tfile);
 		xdp_do_flush_map();
 	}
