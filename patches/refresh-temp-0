Bottom: 8ee5d4ef60f90b2c0bb51d8b9ee2cf1d1c88f53e
Top:    54873b83635db3fe2471762a3e20b447418c1229
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-05-17 14:34:32 +0800

Refresh of introduce-skb_ring

---

diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index ccb025a..17a5faf 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -145,143 +145,6 @@ struct tun_pcpu_stats {
 	u32 rx_frame_errors;
 };
 
-#if 0
-struct skb_desc {
-	struct sk_buff *skb;
-	int len; /* Cached skb len for peeking */
-};
-
-struct skb_ring {
-	/* reader lock */
-	spinlock_t rlock;
-	unsigned long tail;
-	unsigned long size;
-	struct skb_desc *descs;
-	unsigned long head;
-	/* writer lock */
-	spinlock_t wlock;
-};
-
-int skb_ring_empty(struct skb_ring *ring)
-{
-	return ACCESS_ONCE(ring->head) == ACCESS_ONCE(ring->tail);
-}
-
-int skb_ring_init(struct skb_ring *ring, unsigned long size)
-{
-	spin_lock_init(&ring->rlock);
-	spin_lock_init(&ring->wlock);
-
-	ring->head = 0;
-	ring->tail = 0;
-
-	ring->descs = kmalloc(size * sizeof *ring->descs, GFP_ATOMIC);
-	if (!ring->descs)
-		return -ENOMEM;
-
-	ring->size = size;
-	/* FIXEME: check power of 2 */
-
-	return 0;
-}
-
-void skb_ring_purge(struct skb_ring *ring)
-{
-	unsigned long head, tail;
-
-	spin_lock_bh(&ring->rlock);
-	spin_lock(&ring->wlock);
-
-	head = smp_load_acquire(&ring->head);
-	tail = ring->tail;
-
-	while (CIRC_CNT(head, tail, ring->size) >= 1) {
-		struct skb_desc *desc = &ring->descs[tail];
-		struct sk_buff *skb = desc->skb;
-		kfree_skb(skb);
-		/* read descriptor before incrementing tail. */
-		smp_store_release(&ring->tail, (tail + 1) & TUN_RING_MASK);
-	}
-
-	spin_unlock(&ring->wlock);
-	spin_unlock_bh(&ring->rlock);
-}
-
-int skb_ring_peek(struct skb_ring *ring)
-{
-	unsigned long head = smp_load_acquire(&ring->head);
-	unsigned long tail = ACCESS_ONCE(ring->tail);
-	int ret = 0;
-
-	if (CIRC_SPACE(head, tail, ring->size) >= 1)
-		ret = ring->descs[tail].len;
-
-	return ret;
-}
-
-int skb_ring_queue_len(struct skb_ring *ring)
-{
-	unsigned long head = ACCESS_ONCE(ring->head);
-	unsigned long tail = ACCESS_ONCE(ring->tail);
-
-	return CIRC_CNT(head, tail, ring->size);
-}
-
-int skb_ring_queue(struct skb_ring *ring, struct sk_buff *skb)
-{
-	unsigned long head, tail;
-	int ret = 0;
-
-	spin_lock(&ring->wlock);
-
-	tail = smp_load_acquire(&ring->tail);
-	head = ring->head;
-
-	if (CIRC_SPACE(head, tail, ring->size) >= 1) {
-		struct skb_desc *desc = &ring->descs[head];
-
-		desc->skb = skb;
-		desc->len = skb->len;
-		if (skb_vlan_tag_present(skb))
-			desc->len += VLAN_HLEN;
-
-		/* produce descriptor before incrementing head. */
-		smp_store_release(&ring->head,
-				(head + 1) & TUN_RING_MASK);
-	} else {
-		ret = -EFAULT;
-	}
-
-	spin_unlock(&ring->wlock);
-
-	return ret;
-}
-
-struct sk_buff *skb_ring_dequeue(struct skb_ring *ring)
-{
-	unsigned long head, tail;
-	struct sk_buff *skb = NULL;
-	struct skb_desc *desc;
-
-	spin_lock(&ring->rlock);
-	/* Read index before reading contents at that index. */
-	head = smp_load_acquire(&ring->head);
-	tail = ring->tail;
-
-	if (CIRC_CNT(head, tail, TUN_RING_SIZE) >= 1) {
-		desc = &ring->descs[tail];
-		skb = desc->skb;
-		/* read descriptor before incrementing tail. */
-		smp_store_release(&ring->tail,
-				(tail + 1) & TUN_RING_MASK);
-	}
-
-	spin_unlock(&ring->rlock);
-
-	return skb;
-}
-#endif
-
 /* A tun_file connects an open character device to a tuntap netdevice. It
  * also contains all socket related structures (except sock_fprog and tap_filter)
  * to serve as one transmit queue for tuntap device. The sock_fprog and
