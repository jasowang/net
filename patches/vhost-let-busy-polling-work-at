Bottom: 6fc86272106f526a9d07343c524612aa493539e6
Top:    f5614bcbe3a960d108b70f15e49a8364e8d124f1
Author: Jason Wang <jasowang@redhat.com>
Date:   2017-09-14 16:43:26 +0800

vhost: let busy polling work at ns granularity

This allows fine grain adjustment for runtime timeout.

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index 58585ec..bc0708d 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -368,16 +368,11 @@ static void vhost_zerocopy_callback(struct ubuf_info *ubuf, bool success)
 	rcu_read_unlock_bh();
 }
 
-static inline unsigned long busy_clock(void)
-{
-	return local_clock() >> 10;
-}
-
 static bool vhost_can_busy_poll(struct vhost_dev *dev,
-				unsigned long endtime)
+				unsigned long long endtime)
 {
 	return likely(!need_resched()) &&
-	       likely(!time_after(busy_clock(), endtime)) &&
+	       likely(!time_after64(local_clock(), endtime)) &&
 	       likely(!signal_pending(current)) &&
 	       !vhost_has_work(dev);
 }
@@ -413,13 +408,13 @@ static int vhost_net_tx_get_vq_desc(struct vhost_net *net,
 				    struct iovec iov[], unsigned int iov_size,
 				    unsigned int *out_num, unsigned int *in_num)
 {
-	unsigned long uninitialized_var(endtime);
+	unsigned long long uninitialized_var(endtime);
 	int r = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov),
 				  out_num, in_num, NULL, NULL);
 
 	if (r == vq->num && vq->busyloop_timeout) {
 		preempt_disable();
-		endtime = busy_clock() + vq->busyloop_timeout;
+		endtime = local_clock() + vq->busyloop_timeout;
 		while (vhost_can_busy_poll(vq->dev, endtime) &&
 		       vhost_vq_avail_empty(vq->dev, vq))
 			cpu_relax();
@@ -617,7 +612,7 @@ static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk)
 	struct vhost_net_virtqueue *rvq = &net->vqs[VHOST_NET_VQ_RX];
 	struct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_TX];
 	struct vhost_virtqueue *vq = &nvq->vq;
-	unsigned long uninitialized_var(endtime);
+	unsigned long long uninitialized_var(endtime);
 	int len = peek_head_len(rvq, sk);
 
 	if (!len && vq->busyloop_timeout) {
@@ -626,7 +621,7 @@ static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk)
 		vhost_disable_notify(&net->dev, vq);
 
 		preempt_disable();
-		endtime = busy_clock() + vq->busyloop_timeout;
+		endtime = local_clock() + vq->busyloop_timeout;
 
 		while (vhost_can_busy_poll(&net->dev, endtime) &&
 		       !sk_has_rx_data(sk) &&
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 9cb3f72..f54d9f7 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -1532,7 +1532,7 @@ long vhost_vring_ioctl(struct vhost_dev *d, int ioctl, void __user *argp)
 			r = -EFAULT;
 			break;
 		}
-		vq->busyloop_timeout = s.num;
+		vq->busyloop_timeout = s.num * NSEC_PER_MSEC;
 		break;
 	case VHOST_GET_VRING_BUSYLOOP_TIMEOUT:
 		s.index = idx;
diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h
index bb7c29b..3fbff72 100644
--- a/drivers/vhost/vhost.h
+++ b/drivers/vhost/vhost.h
@@ -148,7 +148,7 @@ struct vhost_virtqueue {
 	/* Ring endianness requested by userspace for cross-endian support. */
 	bool user_be;
 #endif
-	u32 busyloop_timeout;
+	u64 busyloop_timeout;
 };
 
 struct vhost_msg_node {
