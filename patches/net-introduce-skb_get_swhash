Bottom: 028eeb771c3f596b66853dce3a22d93425848187
Top:    163f73e69bbc6422f86a81d86bef97a56c493c23
Author: Jason Wang <jasowang@redhat.com>
Date:   2015-06-25 16:54:07 +0800

net: introduce skb_get_sw_hash()

Some users want to use software hash explicitly, this patch record the
sw_hash explicitly in sk_buff and introduce the skb_get_sw_hash() to
fetch the value explicitly.

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index b57eebf..bea166d 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -485,13 +485,13 @@ static inline u32 skb_mstamp_us_delta(const struct skb_mstamp *t1,
  *	@tc_index: Traffic control index
  *	@tc_verd: traffic control verdict
  *	@hash: the packet hash
+ *	@sw_hash: the packet hash that was computed in software stack
  *	@queue_mapping: Queue mapping for multiqueue devices
  *	@xmit_more: More SKBs are pending for this queue
  *	@ndisc_nodetype: router type (from link layer)
  *	@ooo_okay: allow the mapping of a socket to a queue to be changed
  *	@l4_hash: indicate hash is a canonical 4-tuple hash over transport
  *		ports.
- *	@sw_hash: indicates hash was computed in software stack
  *	@wifi_acked_valid: wifi_acked was set
  *	@wifi_acked: whether frame was acked on wifi or not
  *	@no_fcs:  Request NIC to treat last 4 bytes as Ethernet FCS
@@ -595,7 +595,6 @@ struct sk_buff {
 	__u8			ip_summed:2;
 	__u8			ooo_okay:1;
 	__u8			l4_hash:1;
-	__u8			sw_hash:1;
 	__u8			wifi_acked_valid:1;
 	__u8			wifi_acked:1;
 
@@ -633,6 +632,7 @@ struct sk_buff {
 	__u32			priority;
 	int			skb_iif;
 	__u32			hash;
+	__u32			sw_hash;
 	__be16			vlan_proto;
 	__u16			vlan_tci;
 #if defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS)
@@ -918,11 +918,21 @@ skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
 	skb->hash = hash;
 }
 
-static inline __u32 skb_get_hash(struct sk_buff *skb)
+static inline __u32 skb_get_sw_hash(struct sk_buff *skb)
 {
-	if (!skb->l4_hash && !skb->sw_hash)
+	if (!skb->sw_hash)
 		__skb_get_hash(skb);
 
+	return skb->sw_hash;
+}
+
+static inline __u32 skb_get_hash(struct sk_buff *skb)
+{
+	if (!skb->l4_hash)
+		return skb_get_sw_hash(skb);
+	else if (skb->sw_hash)
+		return skb->sw_hash;
+
 	return skb->hash;
 }
 
diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c
index 703d059..a979f61 100644
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -463,8 +463,7 @@ void __skb_get_hash(struct sk_buff *skb)
 		return;
 	if (keys.ports.ports)
 		skb->l4_hash = 1;
-	skb->sw_hash = 1;
-	skb->hash = hash;
+	skb->sw_hash = hash;
 }
 EXPORT_SYMBOL(__skb_get_hash);
