Bottom: 555676672e33e7e1522b23eeaa3b8513dd6fe28d
Top:    b7a6f2374d2f2e6c07202c264d2b111007279900
Author: = <=>
Date:   2016-12-07 17:21:42 +0800

macvtap: tx batching

rx_batched=0 : 0.80Mpps
rx_batched=32: 1.09Mpps

Signed-off-by: = <=>
Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c
index 4026185..798174f 100644
--- a/drivers/net/macvtap.c
+++ b/drivers/net/macvtap.c
@@ -23,6 +23,10 @@
 #include <linux/virtio_net.h>
 #include <linux/skb_array.h>
 
+static int rx_batched = 0;
+module_param(rx_batched, int, 0444);
+MODULE_PARM_DESC(rx_batched, "Number of packets batched in rx");
+
 /*
  * A macvtap queue is the central object of this driver, it connects
  * an open character device to a macvlan interface. There can be
@@ -539,6 +543,7 @@ static void macvtap_sock_destruct(struct sock *sk)
 {
 	struct macvtap_queue *q = container_of(sk, struct macvtap_queue, sk);
 
+	skb_queue_purge(&sk->sk_write_queue);
 	skb_array_cleanup(&q->skb_array);
 }
 
@@ -660,12 +665,45 @@ static inline struct sk_buff *macvtap_alloc_skb(struct sock *sk, size_t prepad,
 	return skb;
 }
 
+static int macvtap_batch_xmit(struct macvtap_queue *q, struct sk_buff *skb,
+			      int more)
+{
+	struct sk_buff_head *queue = &q->sk.sk_write_queue;
+	struct sk_buff_head process_queue;
+	int qlen;
+	bool rcv = false;
+
+	spin_lock(&queue->lock);
+	qlen = skb_queue_len(queue);
+	if (qlen > rx_batched)
+		goto drop;
+	__skb_queue_tail(queue, skb);
+	if (!more || qlen + 1 > rx_batched) {
+		__skb_queue_head_init(&process_queue);
+		skb_queue_splice_tail_init(queue, &process_queue);
+		rcv = true;
+	}
+	spin_unlock(&queue->lock);
+
+	if (rcv) {
+		while ((skb = __skb_dequeue(&process_queue)))
+			dev_queue_xmit(skb);
+	}
+
+	return 0;
+drop:
+	spin_unlock(&queue->lock);
+	kfree_skb(skb);
+	return -EFAULT;
+}
+
 /* Neighbour code has some assumptions on HH_DATA_MOD alignment */
 #define MACVTAP_RESERVE HH_DATA_OFF(ETH_HLEN)
 
 /* Get packet from user space buffer */
 static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,
-				struct iov_iter *from, int noblock)
+				struct iov_iter *from, int noblock,
+				int more)
 {
 	int good_linear = SKB_MAX_HEAD(MACVTAP_RESERVE);
 	struct sk_buff *skb;
@@ -778,8 +816,11 @@ static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,
 	}
 
 	if (vlan) {
-		skb->dev = vlan->dev;
-		dev_queue_xmit(skb);
+		if (!rx_batched) {
+			skv->dev = vlan->lowerdev;
+			dev_queue_xmit(skb);
+		} else
+			macvtap_batch_xmit(q, skb, more);
 	} else {
 		kfree_skb(skb);
 	}
@@ -805,7 +846,8 @@ static ssize_t macvtap_write_iter(struct kiocb *iocb, struct iov_iter *from)
 	struct file *file = iocb->ki_filp;
 	struct macvtap_queue *q = file->private_data;
 
-	return macvtap_get_user(q, NULL, from, file->f_flags & O_NONBLOCK);
+	return macvtap_get_user(q, NULL, from,
+				file->f_flags & O_NONBLOCK, false);
 }
 
 /* Put packet to the user space buffer */
@@ -1187,7 +1229,9 @@ static int macvtap_sendmsg(struct socket *sock, struct msghdr *m,
 			   size_t total_len)
 {
 	struct macvtap_queue *q = container_of(sock, struct macvtap_queue, sock);
-	return macvtap_get_user(q, m, &m->msg_iter, m->msg_flags & MSG_DONTWAIT);
+	return macvtap_get_user(q, m, &m->msg_iter,
+				m->msg_flags & MSG_DONTWAIT,
+				m->msg_flags & MSG_MORE);
 }
 
 static int macvtap_recvmsg(struct socket *sock, struct msghdr *m,
