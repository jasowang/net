Bottom: 6ce21e3ce6012d1136f69d476e10f4b4a1195da9
Top:    cc93e0fa125f9f1892306d94aa785e9a125b8a35
Author: Jason Wang <jasowang@redhat.com>
Date:   2016-12-16 15:38:21 +0800

macvtap: XDP fast rx support

Signed-off-by: Jason Wang <jasowang@redhat.com>


---

diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c
index 5da9861..d7f3c55 100644
--- a/drivers/net/macvtap.c
+++ b/drivers/net/macvtap.c
@@ -45,6 +45,7 @@ struct macvtap_queue {
 	bool enabled;
 	struct list_head next;
 	struct skb_array skb_array;
+	struct ptr_ring xdp_array;
 };
 
 #define MACVTAP_FEATURES (IFF_VNET_HDR | IFF_MULTI_QUEUE)
@@ -352,6 +353,13 @@ static void macvtap_del_queues(struct net_device *dev)
 	vlan->numvtaps = MAX_MACVTAP_QUEUES;
 }
 
+static macvtap_xdp_rx(const struct sk_buff *skb, const struct bfp_insn *filter)
+{
+	struct xdp_buff *buff = (struct xdp_buff *)skb;
+
+	if (__ptr_ring_full(&
+}
+
 static rx_handler_result_t macvtap_handle_frame(struct sk_buff **pskb)
 {
 	struct sk_buff *skb = *pskb;
@@ -536,6 +544,11 @@ static void macvtap_sock_destruct(struct sock *sk)
 	skb_array_cleanup(&q->skb_array);
 }
 
+static void macvtap_xdp_free(void *ptr)
+{
+	kfree(ptr);
+}
+
 static int macvtap_open(struct inode *inode, struct file *file)
 {
 	struct net *net = current->nsproxy->net_ns;
@@ -580,6 +593,9 @@ static int macvtap_open(struct inode *inode, struct file *file)
 	if (skb_array_init(&q->skb_array, dev->tx_queue_len, GFP_KERNEL))
 		goto err_array;
 
+	if (ptr_ring_init(&q->xdp_array, dev->tx_queue_len, GFP_KERNEL))
+		goto err_xdp;
+
 	err = macvtap_set_queue(dev, file, q);
 	if (err)
 		goto err_queue;
@@ -590,6 +606,8 @@ static int macvtap_open(struct inode *inode, struct file *file)
 	return err;
 
 err_queue:
+	ptr_ring_cleanup(&q->xdp_array, macvtap_xdp_free);
+err_xdp:
 	skb_array_cleanup(&q->skb_array);
 err_array:
 	sock_put(&q->sk);
